/* -*-c++-*- */
/**
 * OsgAL - OpenSceneGraph Audio Library
 * Copyright (C) 2004 VRlab, Umeå University
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
 */
#ifndef osgAL_SoundNode_
#define osgAL_SoundNode_ 1


#include "osgAL/Export"
#include "osgAL/SoundState"
#include "osgAL/OccludeCallback"


#include <osg/ref_ptr>
#include <osg/observer_ptr>
#include <osg/Object>
#include <osg/Node>
#include <osg/NodeVisitor>
#include <osg/CopyOp>
#include <osg/Vec3>
#include <osg/Matrix>


namespace osgAL
{
  
  /// A placeholder for a soundstate. The transformation is updated automatically during update traversal.
  /**
    This class implements a scenegraph node has a SoundState associated to it. 
    During cull traversal the orientation and position in world coordinates is calculated for this node and
    fed to the SoundSystem. This ensures that the node follows any transformation above this node.
   */
  class OSGAL_EXPORT SoundNode: public osg::Node {
  public:
    
    /// Default constructor
    SoundNode();
    
    /*!
      Constructor that also associates a sound state to this node.
    */
    SoundNode(SoundState *sound_state);
    
    /// Copy constructor
    SoundNode(const SoundNode &copy, const osg::CopyOp &copyop = osg::CopyOp::SHALLOW_COPY);
    
	META_Node(osgAL ,SoundNode);

    /// Associates a soundstate with this SoundNode.
    void setSoundState(SoundState *sound_state) { m_sound_state = sound_state; }
    
    /// Returns a reference to to the Soundstate associated with this SoundNode
    SoundState *getSoundState() { return m_sound_state.get(); }
    
    /// Returns a const reference to to the Soundstate associated with this SoundNode
    const SoundState *getSoundState() const { return m_sound_state.get(); }    
    
	/// Updates the transformation of the SoundState during Cull traversal.
    void traverse(osg::NodeVisitor &nv);
  
  
	void setOccludeCallback(OccludeCallback *cb) { m_occlude_callback = cb; }
	OccludeCallback *getOccludeCallback() { return m_occlude_callback.get(); }  
	const OccludeCallback *getOccludeCallback() const { return m_occlude_callback.get(); }  
  protected:
    
    /// Destructor
    virtual ~SoundNode() {}
    
    /// Assignment operator
    SoundNode &operator=(const SoundNode &node); 
    
    /*!@Todo: The SoundState should be referenced with a ref_ptr,
       This currently causes problem, as the soundstate, and therefore any referenced soundsources
       are held, until this node is deleted. Which can be by OpenSceneGraph model cache. The time of this event can
       be late, outside the scope of main. This causes problems with OpenAL, which for some reason reports an invalid
       context during the deletion of that source. Therefore, just an ordinary pointer. Memory is properly
       deallocated by the SoundManager, so its not really a problem.
    */
    osg::observer_ptr<SoundState> m_sound_state;

  private:
  
    osg::ref_ptr<OccludeCallback> m_occlude_callback;
    double m_last_time;
    bool m_first_run;
    osg::Vec3 m_last_pos;
    int m_last_traversal_number;
  };
   
  // INLINE FUNCTIONS
  
  
}


#endif
