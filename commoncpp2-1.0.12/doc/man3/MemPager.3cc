.TH "MemPager" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MemPager \- The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object. Accumulative object memory allocator. 
.SH SYNOPSIS
.br
.PP
\fC#include <misc.h>\fP
.PP
Inherited by \fBKeydata\fP\fC [protected]\fP, and \fBSharedMemPager\fP.
.PP
.SS "Public Methods"

.in +1c
.ti -1c
.RI "int \fBgetPages\fP (void)"
.br
.RI "\fIReturn the total number of pages that have been allocated for this memory pool.\fP"
.in -1c
.SS "Protected Methods"

.in +1c
.ti -1c
.RI "virtual void * \fBfirst\fP (size_t \fBsize\fP)"
.br
.RI "\fIAllocate first workspace from paged memory.\fP"
.ti -1c
.RI "virtual void * \fBalloc\fP (size_t \fBsize\fP)"
.br
.RI "\fIAllocate memory from either the currently active page, or allocate a new page for the object.\fP"
.ti -1c
.RI "char * \fBfirst\fP (char *str)"
.br
.RI "\fIAllocate a string from the memory pager pool and copy the string into it's new memory area.\fP"
.ti -1c
.RI "char * \fBalloc\fP (char *str)"
.br
.RI "\fIAllocate a string from the memory pager pool and copy the string inti it's new memory area.\fP"
.ti -1c
.RI "\fBMemPager\fP (int pagesize=4096)"
.br
.RI "\fICreate a paged memory pool for cumulative storage.\fP"
.ti -1c
.RI "void \fBpurge\fP (void)"
.br
.RI "\fIpurge the current memory pool.\fP"
.ti -1c
.RI "virtual \fB~MemPager\fP ()"
.br
.RI "\fIDelete the memory pool and all allocated memory.\fP"
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
The memory pager is used to allocate cumulative memory pages for storing object specific 'persistant' data that is presumed to persist during the life of a given derived object. Accumulative object memory allocator.
.PP
When the object is destroyed, all accumulated data is automatically purged.
.PP
There are a number of odd and specialized utility classes found in Common C++. The most common of these is the 'MemPager' class. This is basically a class to enable page-grouped 'cumulative' memory allocation; all accumulated allocations are dropped during the destructor. This class has found it's way in a lot of other utility classes in Common C++.
.PP
\fBAuthor: \fP
.in +1c
David Sugar <dyfet@ostel.com> 
.PP
.SH "CONSTRUCTOR & DESTRUCTOR DOCUMENTATION"
.PP 
.SS "MemPager::MemPager (int pagesize = 4096)\fC [protected]\fP"
.PP
Create a paged memory pool for cumulative storage.
.PP
This pool allocates memory in fixed 'pagesize' chunks. Ideal performance is achived when the pool size matches the system page size. This pool can only exist in derived objects.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIpagesize\fP\fP
page size to allocate chunks. 
.SS "virtual MemPager::~MemPager ()\fC [protected, virtual]\fP"
.PP
Delete the memory pool and all allocated memory.
.PP
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "char* MemPager::alloc (char * str)\fC [protected]\fP"
.PP
Allocate a string from the memory pager pool and copy the string inti it's new memory area.
.PP
This checks only the last active page for available space before allocating a new page.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIstr\fP\fP
string to allocate and copy into paged memory pool. 
.PP
\fBReturns: \fP
.in +1c
copy of string from allocated memory. 
.SS "virtual void* MemPager::alloc (size_t size)\fC [protected, virtual]\fP"
.PP
Allocate memory from either the currently active page, or allocate a new page for the object.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsize\fP\fP
size of memory to allocate. 
.PP
\fBReturns: \fP
.in +1c
pointer to allocated memory. 
.PP
Reimplemented in \fBSharedMemPager\fP.
.SS "char* MemPager::first (char * str)\fC [protected]\fP"
.PP
Allocate a string from the memory pager pool and copy the string into it's new memory area.
.PP
This method allocates memory by first searching for an available page, and then allocating a new page if no space is found.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIstr\fP\fP
string to allocate and copy into paged memory pool. 
.PP
\fBReturns: \fP
.in +1c
copy of string from allocated memory. 
.SS "virtual void* MemPager::first (size_t size)\fC [protected, virtual]\fP"
.PP
Allocate first workspace from paged memory.
.PP
This method scans all currently allocated blocks for available space before adding new pages and hence is both slower and more efficient.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsize\fP\fP
size of memory to allocate. 
.PP
\fBReturns: \fP
.in +1c
pointer to allocated memory. 
.PP
Reimplemented in \fBSharedMemPager\fP.
.SS "int MemPager::getPages (void)\fC [inline]\fP"
.PP
Return the total number of pages that have been allocated for this memory pool.
.PP
\fBReturns: \fP
.in +1c
number of pages allocated. 
.SS "void MemPager::purge (void)\fC [protected]\fP"
.PP
purge the current memory pool.
.PP
Reimplemented in \fBSharedMemPager\fP.

.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
