#!/usr/bin/env python

# Copyright 2004 Mark Rose <mkrose@users.sourceforge.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""
Decode SimData stack traces under GNU/Linux.

Reads a stack trace from stdin, and dumps a more readable form of
the stack trace to stdout.  The easiest way to use this program is
to select the stack trace using the mouse, run %(prog)s, and then
paste the stack trace into the terminal window (you'll also need
to type <ctrl-d> to close stdin).

Caveats:

This program relies on the addr2line utility to convert symbol
offsets into source file and line numbers, as well as to demangle
C++ symbol names.  When SimData supports stack trace generation under
Windows, a comparable mechanism for decoding them will be devised.

Since the stack trace includes relative paths to shared libraries,
this program must be run from the same directory as the program
that generated the stack trace.  Alternatively, you can specify the
'--dir' flag to set the base directory.  Either way, the program
and all shared libaries must be available in order to properly
decode the stack trace.

Usage: %(prog)s [options]
"""

import sys
import os
import re
import os.path

from csp.base import app


re_trace = re.compile(r'([0-9A-Fa-f]{8})\s+([0-9A-Fa-f]{8})\s+([0-9A-Fa-f]{8})\s+(\S+)\s*(\S*)')


def addr2line(bin, offsets):
	"""
	Translate object file offsets into a source file name and line number.

	The object file must have been compiled with debugging symbols (and not
	subsequently stripped).  The offsets parameter is a list of 2-tuples, each tuple
	holding a primary and an alternate offset into the object file.
	"""
	# expand primary and alternate offsets into a single argument list
	args = ' '.join(['%x %x' % (x, y) for x, y in offsets])
	result = []
	row = []
	for line in os.popen('addr2line -C -f -e %s %s' % (bin, args)):
		row.append(line.strip())
		# each offset returns two lines (symbol name and file position), so there
		# are four lines per input tuple:
		#   row = [primary_sname, primary_file_pos, alt_sname, alt_file_pos]
		if len(row) == 4:
			result.append(row)
			row = []
	return result


def fixpath(dir, path):
	"""
	Translate a path relative to the specified directory.  Absolute paths are unchanged.
	"""
	if not os.path.isabs(path):
		path = os.path.join(dir, path)
		path = os.path.normpath(path)
	return path


class DecodeStackTrace:

	def __init__(self, input, dir='.'):
		# print something early to indicate that we are working (the decode can take a while)
		print '============='
		trace = self._parse(input);
		info, libs = self._analyze(trace)
		self._process(info, libs, dir)
		self._output(info)

	def _parse(self, input):
		"""Extract trace fields from the raw input."""
		trace = []
		for line in input:
			line = line.rstrip()
			if not line: continue
			m = re_trace.match(line)
			if m: trace.append(m.groups())
		return trace

	def _analyze(self, trace):
		"""Determine symbol offsets for each library."""
		info = []
		libs = {}
		for addr, bofs, sofs, file, sym in trace:
			addr = int(addr, 16)
			bofs = int(bofs, 16)
			sofs = int(sofs, 16)
			ofs, alt = addr, sofs
			if file.endswith('.so') or file.find('.so.') > 0:
				ofs, alt = bofs, bofs - sofs
				if alt < 0: alt = sofs
			libs.setdefault(file, []).append((len(info), ofs, alt))
			info.append([addr, sym, file])
		return info, libs

	def _process(self, info, libs, dir):
		"""Use addr2line to translate library offsets into symbol names and file positions."""
		for file, addrlist in libs.items():
			file = fixpath(dir, file)
			offsets = [(ofs, alt) for (idx, ofs, alt) in addrlist]
			decode = addr2line(file, offsets)
			for data, ofs in zip(decode, addrlist):
				idx = ofs[0]
				info[idx].extend(data)

	def _output(self, info):
		"""Print the decoded stack trace."""
		for idx in range(len(info)):
			addr, sym, file, sname, fileline, alt_sname, alt_fileline = (info[idx] + ['??', '??:0', '??', '??:0'])[:7]
			if sname == '??':
				sname = sym
				fileline = file
			elif fileline == '??:0':
				fileline = file
			if alt_sname == sname or alt_sname == '??':
				print '%2d: %08x %s (%s)' % (idx, addr, sname, fileline)
			else:
				print '%2d: %08x %s (%s)' % (idx, addr, sname, fileline)
				print '             from %s (%s)' % (alt_sname, alt_fileline)


def main(args):
	if args:
		app.usage()
		return 1

	try:
		input = sys.stdin.readlines()
	except KeyboardInterrupt:
		return 0

	DecodeStackTrace(input, app.options.dir)
	return 0


app.addOption('-d', '--dir', default='.', help='specify the starting directory of the program that generated the stack trace')
app.start()


