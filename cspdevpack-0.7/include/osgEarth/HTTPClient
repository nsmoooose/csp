/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_HTTP_CLIENT_H
#define OSGEARTH_HTTP_CLIENT_H 1

#include <osgEarth/Common>
#include <osgEarth/Progress>
#include <OpenThreads/Thread>
#include <osg/ref_ptr>
#include <osg/Referenced>
#include <osgDB/ReaderWriter>
#include <sstream>
#include <iostream>
#include <string>
#include <map>
#include <vector>


namespace osgEarth
{
    /**
     * An HTTP request for use with the HTTPClient class.
     */
    class OSGEARTH_EXPORT HTTPRequest
    {
    public:
        HTTPRequest( const std::string& url );

        HTTPRequest( const HTTPRequest& rhs );

        void addParameter( const std::string& name, const std::string& value );
        void addParameter( const std::string& name, int value );
        void addParameter( const std::string& name, double value );
        
        typedef std::map<std::string,std::string> Parameters;

        const Parameters& getParameters() const;

        std::string getURL() const;
        
    private:
        Parameters _parameters;
        std::string _url;
    };


    /**
     * An HTTP response object for use with the HTTPClient class - supports
     * multi-part mime responses.
     */
    class OSGEARTH_EXPORT HTTPResponse
    {
    public:
        enum Code {
            NONE         = 0,
            OK           = 200,
            NOT_FOUND    = 404,
            SERVER_ERROR = 500
        };

    public:
        HTTPResponse( long code =0L );

        HTTPResponse( const HTTPResponse& rhs );

        long getCode() const;

        bool isOK() const;

        bool isCancelled() const;

        unsigned int getNumParts() const;

        std::istream& getPartStream( unsigned int n ) const;

        std::string getPartAsString( unsigned int n ) const;

        unsigned int getPartSize( unsigned int n ) const;
        
        const std::string& getPartHeader( unsigned int n, const std::string& name ) const;

        const std::string& getMimeType() const;

    private:
        struct Part : public osg::Referenced
        {
            Part() : _size(0) { }
            typedef std::map<std::string,std::string> Headers;
            Headers _headers;
            unsigned int _size;
            std::stringstream _stream;
        };
        typedef std::vector< osg::ref_ptr<Part> > Parts;
        Parts _parts;
        long _response_code;
        std::string _mimeType;
        bool _cancelled;

        friend class HTTPClient;
    };


    class OSGEARTH_EXPORT HTTPClient : public osg::Referenced
    {
    public:
        enum ResultCode {
            RESULT_OK,
            RESULT_CANCELED,
            RESULT_NOT_FOUND,
            RESULT_SERVER_ERROR,
            RESULT_TIMEOUT,
            RESULT_NO_READER,
            RESULT_READER_ERROR,
            RESULT_UNKNOWN_ERROR
        };

        // returns true is the result code represents a recoverable
        // situation, i.e. one in which retrying might work.
        static bool isRecoverable( ResultCode code )
        {
            return
                code == RESULT_OK ||
                code == RESULT_SERVER_ERROR ||
                code == RESULT_TIMEOUT ||
                code == RESULT_CANCELED;
        }

        static std::string getResultCodeString( ResultCode code )
        {
            return
                code == RESULT_OK ? "OK" :
                code == RESULT_CANCELED ? "Read canceled" :
                code == RESULT_NOT_FOUND ? "Target not found" :
                code == RESULT_SERVER_ERROR ? "Server error" :
                code == RESULT_TIMEOUT ? "Read timed out" :
                code == RESULT_NO_READER ? "No suitable ReaderWriter found" :
                code == RESULT_READER_ERROR ? "ReaderWriter error" :
                "Unknown error";
        }

    public:
        static ResultCode readImageFile(
            const std::string& uri,
            osg::ref_ptr<osg::Image>& output,
            const osgDB::ReaderWriter::Options* options = 0,
            ProgressCallback* callback = 0 );

        static ResultCode readNodeFile(
            const std::string& uri,
            osg::ref_ptr<osg::Node>& output,
            const osgDB::ReaderWriter::Options* options = 0,
            ProgressCallback* callback = 0 );

        static ResultCode readString(
            const std::string& uri,
            std::string& output,
            ProgressCallback* callback =0);

    public:

        /**
         * Performs an HTTP "GET".
         */
        static HTTPResponse get( const HTTPRequest& request,
                                 const osgDB::ReaderWriter::Options* = 0,
                                 ProgressCallback* callback = 0);

        static HTTPResponse get( const std::string& url,
                                 const osgDB::ReaderWriter::Options* options = 0,
                                 ProgressCallback* callback = 0);

    private:
        HTTPClient();
        ~HTTPClient();

        void readOptions( const osgDB::ReaderWriter::Options* options, std::string &proxy_host, std::string &proxy_port ) const;

        HTTPResponse doGet( const HTTPRequest& request,
                            const osgDB::ReaderWriter::Options* options = 0,
                            ProgressCallback* callback = 0) const;

        HTTPResponse doGet( const std::string& url,
                            const osgDB::ReaderWriter::Options* options = 0,
                            ProgressCallback* callback = 0 ) const;

        ResultCode doReadImageFile(
            const std::string& filename,
            osg::ref_ptr<osg::Image>& output,
            const osgDB::ReaderWriter::Options* options = 0,
            ProgressCallback *callback = 0);

        ResultCode doReadNodeFile(
            const std::string& filename,
            osg::ref_ptr<osg::Node>& output,
            const osgDB::ReaderWriter::Options* options = 0,
            ProgressCallback *callback = 0);

        ResultCode doReadString(
            const std::string& filename,
            std::string& output,
            ProgressCallback *callback = 0);


        /**
         * Convenience method for downloading a URL directly to a file
         */
        bool downloadFile(const std::string& url, const std::string& filename);

    private:
        void *_curl_handle;
        std::string _previousPassword;
        long        _previousHttpAuthentication;


        static HTTPClient& getClient();

    private:
        void decodeMultipartStream(
            const std::string&   boundary,
            HTTPResponse::Part*  input,
            HTTPResponse::Parts& output) const;
    };
}

#endif // OSGEARTH_HTTP_CLIENT_H
