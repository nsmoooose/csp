.TH "StringTokenizer" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StringTokenizer \- Splits delimited string into tokens. 
.SH SYNOPSIS
.br
.PP
\fC#include <misc.h>\fP
.PP
.SS "Public Methods"

.in +1c
.ti -1c
.RI "\fBStringTokenizer\fP (const char *str, const char *delim, bool skipAllDelim=false, bool trim=false)"
.br
.RI "\fIcreates a new StringTokenizer for a string and a given set of delimiters.\fP"
.ti -1c
.RI "\fBStringTokenizer\fP (const char *s)"
.br
.RI "\fIcreate a new StringTokenizer which splits the input string at whitespaces.\fP"
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () const"
.br
.RI "\fIreturns the begin iterator\fP"
.ti -1c
.RI "void \fBsetDelimiters\fP (const char *d)"
.br
.RI "\fIchanges the set of delimiters used in subsequent iterations.\fP"
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP (const char *d)"
.br
.RI "\fIreturns a begin iterator with an alternate set of delimiters.\fP"
.ti -1c
.RI "const \fBiterator\fP & \fBend\fP () const"
.br
.RI "\fIthe iterator marking the end.\fP"
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "const char *const \fBSPACE\fP"
.br
.RI "\fIa delimiter string containing all usual whitespace delimiters.\fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBStringTokenizer::iterator\fP"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
Splits delimited string into tokens.
.PP
The StringTokenizer takes a pointer to a string and a pointer to a string containing a number of possible delimiters. The StringTokenizer provides an input forward iterator which allows to iterate through all tokens. An iterator behaves like a logical pointer to the tokens, i.e. to shift to the next token, you've  to increment the iterator, you get the token by dereferencing the iterator.
.PP
Memory consumption: This class operates on the original string and only allocates memory for the individual tokens actually requested, so this class  allocates at maximum the space required for the longest token in the  given string. Since for each iteration, memory is reclaimed for the last token, you MAY NOT store pointers to them; if you need them afterwards, copy them. You may not modify the original string while you operate on it with the StringTokenizer; the behaviour is undefined in that case.
.PP
The iterator has one special method 'nextDelimiter()' which returns a character containing the next delimiter following this tokenization process or '\\0', if there are no following delimiters. In case of skipAllDelim, it returns the FIRST delimiter.
.PP
With the method '\fBsetDelimiters(const char*)\fP' you may change the set of delimiters. It affects all running iterators.
.PP
Example: \fC
.PP
.nf

  StringTokenizer st('mary had a little lamb;its fleece was..', ' ;');
  \fBStringTokenizer::iterator\fP i;
  for (i = st.begin() ; i != st.end() ; ++i) {
        cout << 'Token: '' << *i << ''\\t';
        cout << ' next Delim: '' << i.nextDelimiter() << ''' << endl;
  }
  
.fi
\fP
.PP
\fBAuthor: \fP
.in +1c
Henner Zeller <H.Zeller@acm.org> @license LGPL 
.PP
.SH "CONSTRUCTOR & DESTRUCTOR DOCUMENTATION"
.PP 
.SS "StringTokenizer::StringTokenizer (const char * str, const char * delim, bool skipAllDelim = false, bool trim = false)"
.PP
creates a new StringTokenizer for a string and a given set of delimiters.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIstr\fP\fP
String to be split up. This string will not be modified by this StringTokenizer, but you may as well not modfiy this string while tokenizing is in process, which may lead to undefined behaviour.
.TP
\fB\fIdelim\fP\fP
String containing the characters which should be regarded as delimiters.
.TP
\fB\fIskipAllDelim\fP\fP
OPTIONAL.  true, if subsequent delimiters should be skipped at once or false, if empty tokens should be returned for two delimiters with no other text inbetween. The first behaviour may be desirable for whitespace skipping, the second for input with delimited entry e.g. /etc/passwd like files or CSV input. NOTE, that 'true' here resembles the  ANSI-C strtok(char *s,char *d) behaviour. DEFAULT = false
.TP
\fB\fItrim\fP\fP
OPTIONAL.  true, if the tokens returned should be trimmed, so that they don't have any whitespaces at the beginning or end. Whitespaces are any of the characters  defined in \fBStringTokenizer::SPACE\fP. If delim itself is \fBStringTokenizer::SPACE\fP, this will result in a behaviour with  skipAllDelim = true. DEFAULT = false 
.SS "StringTokenizer::StringTokenizer (const char * s)"
.PP
create a new StringTokenizer which splits the input string at whitespaces.
.PP
The tokens are stripped from whitespaces. This means, if you change the set of delimiters in either the '\fBbegin(const char *delim)\fP' method or in '\fBsetDelimiters()\fP', you then get whitespace trimmed tokens, delimited by the new set. Behaves like StringTokenizer(s, StringTokenizer::SPACE,false,true); 
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "\fBiterator\fP StringTokenizer::begin (const char * d)\fC [inline]\fP"
.PP
returns a begin iterator with an alternate set of delimiters.
.PP
.SS "\fBiterator\fP StringTokenizer::begin () const\fC [inline]\fP"
.PP
returns the begin iterator
.PP
.SS "const \fBiterator\fP& StringTokenizer::end () const\fC [inline]\fP"
.PP
the iterator marking the end.
.PP
.SS "void StringTokenizer::setDelimiters (const char * d)\fC [inline]\fP"
.PP
changes the set of delimiters used in subsequent iterations.
.PP
.SH "FRIENDS AND RELATED FUNCTION DOCUMENTATION"
.PP 
.SS "friend class StringTokenizer::iterator\fC [friend]\fP"
.PP
.SH "MEMBER DATA DOCUMENTATION"
.PP 
.SS "const char* const StringTokenizer::SPACE\fC [static]\fP"
.PP
a delimiter string containing all usual whitespace delimiters.
.PP
These are space, tab, newline, carriage return, formfeed and vertical tab. (see isspace() manpage). 

.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
