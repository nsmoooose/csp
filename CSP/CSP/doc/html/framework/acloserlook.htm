<HTML>
<HEAD>
<TITLE>A Closer Look</TITLE>
</HEAD>
<BODY>
By Brandon Bohn
<BR>
<BR>
Lets take a closer look at the Framework. How the factories work and implementation.<BR>
<BR>
<B>Implementation</B>
<BR>
<BR>
<I>D</I> - Implementation is a platform or API specific code contained inside a platform independant "wrapper."<BR>
<BR>
Implementation consists of:<BR>
<BR>
<U>Standard*.h</U><BR>
<U>Types*.h</U><BR>
<U>Specific.h</U> and <U>Specific.cpp</U><BR>
<BR>
<U>Standard*.h</U> is a pure virtual class.  Meaning there is no code associated with <U>Standard*.h</U>. This is just the platform independant interface which the rest of the code will use.<BR>
<BR>
This <U>Standard*.h</U> must remain platform and API independant. Meaning, you can't use API specific types such as "D3DMATRIX" and you can't use platform specific types such as "DWORD."  This will make things more difficult, but it's a step that is required to remain independant.<BR>
<BR>
<U>Specific.h</U> and <U>Specific.cpp</U> are API specific code which inherits the <U>Standard*.h</U>.  <U>Specific.cpp</U> is where the implementation of <U>Standard*.h</U> is.<BR>
<BR>
<U>Types*.h</U> will contain a standard set of structs, types, constants and #defines for the <U>Standard*.h</U> and API specific classes.<BR>
<BR>

The class layout is as followed.

<TABLE BORDER=0 BGCOLOR="0099FF">
<TR>
<TD>
Standard*.h
</TD>
<TD>
<TABLE BORDER=0>
<TR>
<TD BGCOLOR="009999">
API1.cpp
</TD>
<TD BGCOLOR="009999">
API1.h
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
API2.cpp
</TD>
<TD BGCOLOR="009999">
API2.h
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
API3.cpp
</TD>
<TD BGCOLOR="009999">
API3.h
</TD>
</TR>
</TABLE>
<TD>
Types*.h
</TD>
</TR>
<TABLE>

<BR>

The classes might look like this:

<TABLE BORDER=1>

<TR>
<TD BGCOLOR="00BBBB">
API1.CPP (specific.cpp)
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
#include "API1.H"<BR>
<BR>
void API1::A_Required_Function(void)<BR>
{<BR>
<BR>
// this would be API specific code in here. Like OpenGL, OpenAL, or sockets.
<BR>
};<BR>
</FONT>
</TD>
</TR>

<TR>
<TD BGCOLOR="00BBBB">
API1.H (specific.h)
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
#include "Standard*.H"<BR>
<BR>
Class API1 : private Standard*<BR>
{<BR>
<BR>
// required because of Standard*.h<BR>
void A_Required_Function(void);<BR>
}<BR>
</FONT>
</TD>
</TR>


<TR>
<TD BGCOLOR="00BBBB">
Standard*.H
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
#include "Types*.h"<BR>
<BR>
Class Standard*<BR>
{<BR>
<BR>
// the platform independant interface<BR>
virtual void A_Required_Function(void) = 0;<BR>
}<BR>
</FONT>
</TD>
</TR>

<TR>
<TD BGCOLOR="00BBBB">
Types*.H
</TD>
</TR>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
<BR>
<BR>
// Available Preprocessors for Graphics API<BR>
// D3D        - Direct3D 8<BR>
// OGL        - OpenGL<BR>
<BR>
// List of API's<BR>
const short _NOGRAPHICS     = -1;<BR>
const short _D3D8           = 0;<BR>
const short _OGL            = 1;<BR>
<BR>
const short DEFAULT_GRAPHICS = _D3D8;<BR>
<BR>
</FONT>
</TD>
</TR>

</TABLE>
<BR>
Anything using your implementation HAS to use the Standard*.h interface.  Meaning, the code has to do a new on the "Standard*" class. Not your "API1" class.  API1 class is hidden inside the implementation.<BR>
<BR>

One of the features of .CPP is abstract classes.  What this means is you can create a Specific.cpp class by using its "pure virtual class" as a type.<BR>
<BR>
Like this:<BR>
<BR>
<TABLE BORDER=1>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
#include "Standard*.h"<BR>
#include "API1.h"<BR>
<BR>
void main(void)<BR>
{<BR>
<BR>
  Standard*  stdint = 0;<BR>
<BR>
  stdinf = new API1;<BR>
<BR>
  stdinf->A_Required_Function();<BR>
<BR>
}<BR>
<BR>
</FONT>
</TD>
</TR>
</TABLE>
<BR>
Doing the code above would actually call the API1's "A_Required_Function" code, even though we have defined this variable as a Standard* class.<BR>
<BR>
Ok ok, I know what you are thinking.   That makes sense, but you have to include API1.h, and thats API specific!?  We don't want that in Framework code.<BR>
<BR>
The answer is the next topic.<BR>
<BR>
<B>Factories</B>
<BR>
<BR>
<I>D</I> - Factories is the Framework's way of returning a specific API through the standard* interface.<BR>
<BR>
Factories consists of:<BR>
<BR>
<U>Factory*.cpp</U><BR>
<U>Factory*.h</U><BR>
<BR>
Factories main point is to create a list of available API's, create the one you desire, and return it's Standard* interface to the calling application.<BR>
<BR>
The first thing it has to do is make a list of available API's.  This is done in its constructor code:<BR>

<TABLE BORDER=1>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
<BR>
#ifdef D3D<BR>
  #include "win/D3D.h"<BR>
#endif<BR>
<BR>
// ------------------------------------------<BR>
//  Constructor / Deconstructor<BR>
// ------------------------------------------<BR>
FactoryGraphics::FactoryGraphics()<BR>
{<BR>
  _GRAPHICS_DESCRIPTION *oldgd;<BR>
  oldgd = 0;<BR>
<BR>
  gd = 0;<BR>
  count = 0;<BR>
<BR>
  // add choice of nothing<BR>
  count++;<BR>
  gd = new _GRAPHICS_DESCRIPTION[count];<BR>
  gd[count - 1].Name = "(no graphics)\0";<BR>
  gd[count - 1].ID = _NOGRAPHICS;<BR>
<BR>
  // add D3D choice<BR>
  #ifdef D3D<BR>
    count++;<BR>
    oldgd = gd;<BR>
    gd = new _GRAPHICS_DESCRIPTION[count];<BR>
    if(count > 1)<BR>
    {<BR>
      memcpy(gd, oldgd, sizeof(_GRAPHICS_DESCRIPTION) * (count - 1));<BR>
    }<BR>
    _DELARRAY(oldgd);<BR>
<BR>
    gd[count - 1].Name = "Direct3D 8\0";<BR>
    gd[count - 1].ID = _D3D8;<BR>
<BR>
  #endif<BR>
<BR>
}<BR>
<BR>
</FONT>
</TD>
</TR>
</TABLE>
<BR>
As you can tell there are #ifdefs in this code.   This is how the factories determine which API's are available for the specific platform.<BR>
<BR>
If you are on a platform which supports Direct3D, the Factory will look for the D3D flag in the preprocessors. If it doesn't exist, Direct3D will not be listed in the available API's.
<BR>
<BR>
You can tell from that code the the API list is being created dynamically at runtime (depending on the preprocessor) when the Factory* is being created.<BR>
<BR>
Now that the factory has a list of API's available, you can use its GetCount and GetDescription functions to see which APIs are available.  After you have found the one you want, you call the Create function with the ID of the API (as defined in the header file Types*.h):

<TABLE BORDER=1>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
<BR>
short FactoryGraphics::Create(short ID, StandardGraphics** Graphics)<BR>
{<BR>
  short x;<BR>
<BR>
  for(x = 0; x < count; x++)<BR>
  {<BR>
    if(gd[x].ID == ID)<BR>
    {<BR>
      break;<BR>
    }<BR>
  }<BR>
<BR>
  if(x > count)<BR>
  {<BR>
    return _BAD_ID;<BR>
  }<BR>
<BR>
  switch(gd[x].ID)<BR>
  {<BR>
<BR>
    case _NOGRAPHICS:<BR>
      *Graphics = new NoGraphicsClass;<BR>
      break;<BR>
<BR>
    #ifdef D3D<BR>
      case _D3D8:<BR>
        *Graphics = new D3DGraphics;<BR>
        break;<BR>
    #endif<BR>
<BR>
    default:<BR>
      *Graphics = 0;<BR>
      return _NOT_IMPLEMENTED;<BR>
      break;<BR>
  }<BR>
<BR>
  return 0;<BR>
}<BR>
<BR>
</TD>
</TR>
</TABLE>

If you look closely, anything regarding Direct3D requires the D3D preprocessor.  If the D3D preprocessor is not defined, the D3D.h will not be included, it won't be in the API list, nor can you Create that API in the Create function.<BR>
<BR>
<B>Putting them together.</B>
<BR>
<BR>
The Create function is using a Standard* interface as a byref pointer. Meaning, your application creates "StandardGraphics *" and then the Create function in the Factory will return you the correct API in that pointer you created.  The application has no #ifdefs and no API specific code. It only has the ability to access the Factory and the Standard*.h interface.
<BR>
<BR>
Here is sample code inside the application to see how to use the factory to get your interface.<BR>

<TABLE BORDER=1>
<TR>
<TD BGCOLOR="009999">
<FONT FACE="Courier">
<BR>
  StandardPlatform      *platform;<BR>
<BR>
  short number;<BR>
  short count;<BR>
<BR>
  FactoryPlatform       *PlatformFactory = 0;<BR>

<BR>
  // -----<BR>
  // PLATFORM<BR>
  // -----<BR>
  _PLATFORM_DESCRIPTION *pd = 0;<BR>
<BR>
  PlatformFactory = new FactoryPlatform;<BR>
<BR>
<BR>
  number = PlatformFactory->GetCount();<BR>
  for(count = 0; count < number; count++)<BR>
  {<BR>
    PlatformFactory->GetDescription(count, &pd);<BR>
    if(pd->ID == DEFAULT_PLATFORM)<BR>
    {<BR>
      PlatformFactory->Create(pd->ID, &platform);<BR>
      // we found our platform we want,  lets break;<BR>
      break;<BR>
    }<BR>
  }<BR>
<BR>
  _DEL(PlatformFactory);<BR>
<BR>
</TD>
</TR>
</TABLE>

We are using the platform as an example instead of graphics.<BR>
<BR>
The first thing we do is create the factory by doing a new on it. Then we ask it the number of platforms available. There is only 1 platform per computer.  So, it should never list more than 1.  We then ask for a description of this platform.  It returns to us in a PLATFORM_DESCRIPTION struct. Thats found in TypesPlatform.h. 
If the platform ID is the same as the DEFAULT_PLATFORM (also defined in TypesPlatform.h) we create that ID.  "platform" variable is our interface into our platform specific class.<BR>
<BR>
<B>How to add my own API</B>
<BR>
<BR>
Adding your own API should be easy.<BR>
<BR>
1. Think up a preprocessor name for your API. Add that to Types*.h.<BR>
2. Create an ID for your API. Add that to Types*.h<BR>
3. Create your implementation for your API that includes Standard*.h.<BR>
4. Add your API to the correct factory. Make sure you are using the #ifdefs correctly.<BR>
5. Test to verify the factory is listing your API as a choice (in its GetCount/GetDescription functions). Make sure you list your preprocessor in your make file.<BR>
6. Test to verify the factory is creating the correct API when you specify your API ID.<BR>
7. Test to make sure when the application is using the Standard*.h for your API, it's actually going inside your API function call.<BR>
8. Submit your code into CVS.<BR>
<BR>

Any questions?  Post on website forum or email brandonb_visi@hotmail.com

</BODY>
</HTML>
