/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_TASK_SERVICE
#define OSGEARTH_TASK_SERVICE 1

#include <osgEarth/Common>
#include <osgEarth/HTTPClient>
#include <OpenThreads/Thread>
#include <OpenThreads/Condition>
#include <OpenThreads/ReentrantMutex>
#include <osg/Referenced>
#include <queue>
#include <list>
#include <string>

namespace osgEarth
{
    class OSGEARTH_EXPORT TaskRequest : public osg::Referenced
    {
    public:
        enum State {
            STATE_IDLE,
            STATE_PENDING,
            STATE_IN_PROGRESS,
            STATE_COMPLETED
        };
    public:
        TaskRequest( float priority =0.0f );

        // the actual task code
        virtual void operator()( ProgressCallback* progress ) =0;

        void run();
        void cancel();

        bool isIdle() const { return _state == STATE_IDLE; }
        bool isPending() const { return _state == STATE_PENDING; }
        bool isCompleted() const { return _state == STATE_COMPLETED; }
        bool isInProgress() const { return _state == STATE_IN_PROGRESS; }
        bool isRunning() const { return isPending() || isInProgress(); }

        bool wasCanceled() const;

        void setPriority( float value ) { _priority = value; }
        float getPriority() const { return _priority; }
        State getState() const { return _state; }
        void setState(State s) { _state = s; }
        void setStamp(int stamp) { _stamp = stamp; }
        int getStamp() const { return _stamp; }
        osg::Referenced* getResult() const { return _result.get(); }
        ProgressCallback* getProgressCallback() { return _progress.get(); }
        void setProgressCallback(ProgressCallback* progress) { _progress = progress? progress : new ProgressCallback(); }
        const std::string& getName() const { return _name; }
        void setName( const std::string& name ) { _name = name; }
        void reset() { _result = 0L; }
    protected:
        float _priority;
        volatile State _state;
        volatile int _stamp;
        osg::ref_ptr<osg::Referenced> _result;
        osg::ref_ptr< ProgressCallback > _progress;
        std::string _name;
    };

    typedef std::list< osg::ref_ptr<TaskRequest> > TaskRequestList;

    class TaskRequestQueue : public osg::Referenced
    {
    public:
        TaskRequestQueue();

        void add( TaskRequest* request );
        TaskRequest* get();
        void clear();

        void setDone();

        void setStamp( int value ) { _stamp = value; }
        int getStamp() const { return _stamp; }

        unsigned int getNumRequests() const;

    private:
        TaskRequestList _requests;
        OpenThreads::Mutex _mutex;
        OpenThreads::Condition _cond;
        volatile bool _done;
        //osg::ref_ptr< osg::RefBlock > _block;

        int _stamp;
    };
    
    struct TaskThread : public OpenThreads::Thread
    {
        TaskThread( TaskRequestQueue* queue );
        bool getDone() { return _done;}
        void setDone( bool done) { _done = done; }
        void run();
        int cancel();

    private:
        osg::ref_ptr<TaskRequestQueue> _queue;
        osg::ref_ptr<TaskRequest> _request;
        volatile bool _done;
    };

    class OSGEARTH_EXPORT TaskService : public osg::Referenced
    {
    public:
        TaskService( const std::string& name ="", int numThreads =4 );

        void add( TaskRequest* request );

        int getStamp() const;
        void setStamp( int stamp );

        int getNumThreads() const;
        void setNumThreads( int numThreads );

        /**
         *Gets the number of requets left in the queue
         */
        unsigned int getNumRequests() const;

    private:
        void adjustThreadCount();
        void removeFinishedThreads();

        OpenThreads::ReentrantMutex _threadMutex;
        typedef std::list<TaskThread*> TaskThreads;
        TaskThreads _threads;
        osg::ref_ptr<TaskRequestQueue> _queue;
        int _numThreads;
        int _lastRemoveFinishedThreadsStamp;
        std::string _name;
        virtual ~TaskService();
    };
}

#endif // OSGEARTH_TASK_SERVICE

