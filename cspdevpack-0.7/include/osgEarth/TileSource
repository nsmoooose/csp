/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_TILE_SOURCE_H
#define OSGEARTH_TILE_SOURCE_H 1

#include <osg/Version>

#include <osgEarth/Common>
#include <osgEarth/TileKey>
#include <osgEarth/Profile>
#include <osgEarth/Caching>
#include <osgEarth/Progress>
#include <osgEarth/DriverOptions>

#include <osg/Referenced>
#include <osg/Object>
#include <osg/Image>
#include <osg/Shape>
#if OSG_MIN_VERSION_REQUIRED(2,9,5)
#include <osgDB/Options>
#endif
#include <osgDB/ReadFile>

#include <OpenThreads/Mutex>

#include <string>


#define TILESOURCE_CONFIG "tileSourceConfig"


namespace osgEarth
{   
    /**
     * Configuration options for a tile source driver.
     */
    class OSGEARTH_EXPORT TileSourceOptions : public DriverOptions
    {
    public: //properties
        
        optional<int>& tileSize() { return _tileSize; }
        const optional<int>& tileSize() const { return _tileSize; }

        optional<float>& noDataValue() { return _noDataValue; }
        const optional<float>& noDataValue() const { return _noDataValue; }

        optional<float>& noDataMinValue() { return _noDataMinValue; }
        const optional<float>& noDataMinValue() const { return _noDataMinValue; }

        optional<float>& noDataMaxValue() { return _noDataMaxValue; }
        const optional<float>& noDataMaxValue() const { return _noDataMaxValue; }

        optional<Config>& profileConfig() { return _profileConf; }
        const optional<Config>& profileConfig() const { return _profileConf; }

    public:
        TileSourceOptions( const PluginOptions* po =0L );

    protected:
        virtual Config toConfig() const;

        optional<int> _tileSize;
        optional<float> _noDataValue, _noDataMinValue, _noDataMaxValue;
        optional<Config> _profileConf;
    };


    /**
     * A TileSource is an object that can create image and/or heightfield tiles. Driver 
     * plugins are responsible for creating and returning a TileSource that the Map
     * will then use to create tiles for tile keys.
     */
    class OSGEARTH_EXPORT TileSource : public virtual osg::Object
    {
    public:        
        TileSource( const PluginOptions* options =NULL ); //const osgDB::ReaderWriter::Options* options =NULL );

        /**
         * Gets the number of pixels per tile for this TileSource.
         */
        virtual int getPixelsPerTile() const;

	    /**
    	 * Creates an image for the given TileKey
		 */
		virtual osg::Image* getImage( const TileKey* key,
                                      ProgressCallback* progress = 0L );

        /**
         * Creates a heightfield for the given TileKey
         */
        virtual osg::HeightField* getHeightField( const TileKey* key,
                                                  ProgressCallback* progress = 0L );

    public:

        /**
         * Returns True if this tile source initialized properly and has a valid
         * profile.
         */
        virtual bool isOK() const;
        bool isValid() const { return isOK(); }

        /**
         * Gets the Profile of the TileSource
         */
        virtual const Profile* getProfile() const;

		/**
		 * Gets the nodata elevation value
		 */
        virtual float getNoDataValue() {
            return _settings->noDataValue().value(); }

		/**
		 * Sets the nodata elevation value
		 */
        //virtual void  setNoDataValue(float noDataValue);

		/**
		 * Gets the nodata min value
		 */
        virtual float getNoDataMinValue() {
            return _settings->noDataMinValue().value(); }

		/**
		 * Sets the nodata min value
		 */
        //virtual void setNoDataMinValue(float noDataMinValue);

		/**
		 * Gets the nodata max value
		 */
        virtual float getNoDataMaxValue() {
            return _settings->noDataMaxValue().value(); }

		/**
		 * Sets the nodata max value
		 */
        //virtual void  setNoDataMaxValue(float noDataMaxValue);     

        /**
         * Gets the extent of available data accessible through this tile source.
         * While the Profile will return extents corresponding to the SRS, this
         * method will reflect the area containing real source data.
         */
        virtual const GeoExtent& getDataExtent() const;

        /**
         * Gets the maximum level of detail available from the tile source. Unlike 
         * getMaxLevel(), which reports the maximum level at which to use this tile 
         * source in a Map, this method reports the maximum level for which the 
         * tile source is able to return data.
         */
        virtual unsigned int getMaxDataLevel() const;

        /**
         * Returns true if data from this source can be cached to disk
         */
        virtual bool supportsPersistentCaching() const;

        /**
         * Gets the preferred extension for this TileSource
         */
        virtual std::string getExtension() const {return "png";}

        virtual osg::Object* cloneType() const { return 0; } // cloneType() not appropriate
        virtual osg::Object* clone(const osg::CopyOp&) const { return 0; } // clone() not appropriate
        virtual bool isSameKindAs(const osg::Object* obj) const { return dynamic_cast<const TileSource*>(obj)!=NULL; }
        virtual const char* className() const { return "TileSource"; }
        virtual const char* libraryName() const { return "osgEarth"; }

		/**
		 * Initialize the TileSource.  The profile should be computed and set here using setProfile()
		 */
		virtual void initialize( const std::string& referenceURI, const Profile* overrideProfile = NULL) = 0;

   
    protected:

		/**
		 * Creates an image for the given TileKey
		 */
		virtual osg::Image* createImage( const TileKey* key,
                                         ProgressCallback* progress  = 0) = 0;

        /**
         * Creates a heightfield for the given TileKey
         */
        virtual osg::HeightField* createHeightField( const TileKey* key, 
                                                     ProgressCallback* progress = 0);

        const TileSourceOptions* getOptions() const {
            return _settings.get(); }

        // Called by a tile source implementation to set the data extent.
        void setDataExtent( const GeoExtent& extent );

        // Called by a tile source implementation to set the maximum data level
        void setMaxDataLevel( unsigned int max_level );

		/**
		 * Called by subclasses to initialize their profile
		 */
		void setProfile( const Profile* profile );

    private:
        osg::ref_ptr<const Profile> _profile;
        osg::ref_ptr<const TileSourceOptions> _settings;

        friend class Map;
        friend class MapEngine;
        friend class TileSourceFactory;

        //float _noDataValue;
        //float _noDataMinValue;
        //float _noDataMaxValue;

        GeoExtent    _dataExtent;
        unsigned int _maxDataLevel;

		osg::ref_ptr<MemCache> _memCache;
    };

    
    typedef std::vector< osg::ref_ptr<TileSource> > TileSourceList;
}

#endif // OSGEARTH_TILE_SOURCE_H
