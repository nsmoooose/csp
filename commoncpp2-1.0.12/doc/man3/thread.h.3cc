.TH "thread.h" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
thread.h \- Synchronization and threading services. 
.SH SYNOPSIS
.br
.PP
\fC#include <cc++/config.h>\fP
.br
\fC#include <cc++/exception.h>\fP
.br
\fC#include <pthread.h>\fP
.br
\fC#include <semaphore.h>\fP
.br
\fC#include <time.h>\fP
.br
\fC#include <signal.h>\fP
.br
\fC#include <unistd.h>\fP
.br
.SS "Compounds"

.in +1c
.ti -1c
.RI "class \fBAtomicCounter\fP"
.br
.RI "\fIThe AtomicCounter class offers thread-safe manipulation of an integer counter. atomic counter operation.\fP"
.ti -1c
.RI "class \fBBuffer\fP"
.br
.RI "\fIThe buffer class represents an IPC service that is built upon a buffer of fixed capacity that can be used to transfer objects between one or more producer and consumer threads. Producer/Consumer buffer for use between threads.\fP"
.ti -1c
.RI "class \fBConditional\fP"
.br
.RI "\fIA conditional variable synchcronization object for one to one and one to many signal and control events between processes. conditional.\fP"
.ti -1c
.RI "class \fBEvent\fP"
.br
.RI "\fIThe Event class implements a feature originally found in the WIN32 API; event notification. \fBThread\fP synchornization on event notification.\fP"
.ti -1c
.RI "class \fBFixedBuffer\fP"
.br
.RI "\fIA buffer class that holds a known capacity of fixed sized objects defined during creation. producer/consumer buffer for fixed size objects.\fP"
.ti -1c
.RI "class \fBMutex\fP"
.br
.RI "\fIThe Mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation. Mutex lock for protected access.\fP"
.ti -1c
.RI "class \fBMutexCounter\fP"
.br
.RI "\fIThe \fBMutex\fP Counter is a counter variable which can safely be incremented or decremented by multiple threads. \fBThread\fP protected integer counter.\fP"
.ti -1c
.RI "class \fBMutexLock\fP"
.br
.RI "\fIThe MutexLock class is used to protect a section of code so that at any given time only a single thread can perform the protected operation. \fBMutex\fP automatic locker for protected access.\fP"
.ti -1c
.RI "class \fBSemaphore\fP"
.br
.RI "\fIA semaphore is generally used as a synchronization object between multiple threads or to protect a limited and finite resource such as a memory or thread pool. Semaphore counter for thread synchronization.\fP"
.ti -1c
.RI "class \fBThread\fP"
.br
.RI "\fIEvery thread of execution in an application is created by instantiating an object of a class derived from the Thread class. base class used to derive all threads of execution.\fP"
.ti -1c
.RI "class \fBThreadKey\fP"
.br
.RI "\fIThis class allows the creation of a thread context unique 'pointer' that can be set and retrieved and can be used to create thread specific data areas for implementing 'thread safe' library routines. container for thread specific data storage.\fP"
.ti -1c
.RI "class \fBThreadLock\fP"
.br
.RI "\fIThe ThreadLock class impliments a thread rwlock for optimal reader performance on systems which have rwlock support, and reverts to a simple mutex for those that do not. Posix rwlock extension for protected access.\fP"
.ti -1c
.RI "class \fBTimerPort\fP"
.br
.RI "\fITimer ports are used to provide synchronized timing events when managed under a 'service thread' such as \fBSocketService\fP. synchronized millisecond timing for service threads.\fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBCCXX_POSIX\fP"
.br
.ti -1c
.RI "#define \fBTIMEOUT_INF\fP   ~((\fBtimeout_t\fP) 0)"
.br
.ti -1c
.RI "#define \fBENTER_CRITICAL\fP   enterMutex();"
.br
.ti -1c
.RI "#define \fBLEAVE_CRITICAL\fP   leaveMutex();"
.br
.ti -1c
.RI "#define \fBENTER_DEFERRED\fP   setCancel(cancelDeferred);"
.br
.ti -1c
.RI "#define \fBLEAVE_DEFERRED\fP   setCancel(cancelImmediate);"
.br
.ti -1c
.RI "#define \fBpsleep\fP(x)   (sleep)(x)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef pthread_t \fBcctid_t\fP"
.br
.ti -1c
.RI "typedef unsigned long \fBtimeout_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "timespec * \fBgetTimeout\fP (struct timespec *spec, \fBtimeout_t\fP timeout)"
.br
.ti -1c
.RI "void \fBwait\fP (signo_t signo)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "CCXX_CLASS_EXPORT \fBThread\fP"
.br
.ti -1c
.RI "CCXX_CLASS_EXPORT \fBThreadKey\fP"
.br
.ti -1c
.RI "CCXX_CLASS_EXPORT \fBEvent\fP"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
Synchronization and threading services.
.PP
.PP
.SH "DEFINE DOCUMENTATION"
.PP 
.SS "#define CCXX_POSIX"
.PP
.SS "#define ENTER_CRITICAL   enterMutex();"
.PP
.SS "#define ENTER_DEFERRED   setCancel(cancelDeferred);"
.PP
.SS "#define LEAVE_CRITICAL   leaveMutex();"
.PP
.SS "#define LEAVE_DEFERRED   setCancel(cancelImmediate);"
.PP
.SS "#define psleep(x)   (sleep)(x)"
.PP
.SS "#define TIMEOUT_INF   ~((\fBtimeout_t\fP) 0)"
.PP
.SH "TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef pthread_t cctid_t"
.PP
.SS "typedef unsigned long timeout_t"
.PP
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "struct timespec* getTimeout (struct timespec * spec, \fBtimeout_t\fP timeout)"
.PP
.SS "void wait (signo_t signo)"
.PP
.SH "VARIABLE DOCUMENTATION"
.PP 
.SS "class CCXX_CLASS_EXPORT Event"
.PP
.SS "class CCXX_CLASS_EXPORT Thread"
.PP
.SS "class CCXX_CLASS_EXPORT ThreadKey"
.PP
.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
