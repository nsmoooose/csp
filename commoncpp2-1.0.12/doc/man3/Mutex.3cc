.TH "Mutex" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Mutex \- The Mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation. Mutex lock for protected access. 
.SH SYNOPSIS
.br
.PP
\fC#include <thread.h>\fP
.PP
Inherited by \fBConditional\fP, \fBMutexCounter\fP, \fBRandomFile\fP\fC [protected]\fP, \fBSerialService\fP\fC [private]\fP, \fBSharedMemPager\fP, and \fBSocketService\fP\fC [private]\fP.
.PP
.SS "Public Methods"

.in +1c
.ti -1c
.RI "\fBMutex\fP ()"
.br
.RI "\fIThe mutex is always initialized as a recursive entity.\fP"
.ti -1c
.RI "virtual \fB~Mutex\fP ()"
.br
.RI "\fIDestroying the mutex removes any system resources associated with it.\fP"
.ti -1c
.RI "void \fBenterMutex\fP (void)"
.br
.RI "\fIEntering a Mutex locks the mutex for the current thread.\fP"
.ti -1c
.RI "bool \fBtryEnterMutex\fP (void)"
.br
.RI "\fITries to lock the mutex for the current thread.\fP"
.ti -1c
.RI "void \fBleaveMutex\fP (void)"
.br
.RI "\fILeaving a mutex frees that mutex for use by another thread.\fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBConditional\fP"
.br
.ti -1c
.RI "class \fBEvent\fP"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
The Mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation. Mutex lock for protected access.
.PP
The Mutex can be used as a base class to protect access in a derived class. When used in this manner, the ENTER_CRITICAL and LEAVE_CRITICAL macros can be used to specify when code written for the derived class needs to be protected by the default Mutex of the derived class, and hence is presumed to be 'thread safe' from multiple instance execution. One of the most basic Common C++ synchronization object is the Mutex class. A Mutex only allows one thread to continue execution at a given time over a specific section of code. Mutex's have a enter and leave method; only one thread can continue from the Enter until the Leave is called. The next thread waiting can then get through. Mutex's are also known as 'CRITICAL SECTIONS' in win32-speak.
.PP
The Mutex is always recursive in that if the same thread invokes the same mutex lock multiple times, it must release it multiple times. This allows a function to call another function which also happens to use the same mutex lock when called directly. This was deemed essential because a mutex might be used to block individual file requests in say, a database, but the same mutex might be needed to block a whole series of database updates that compose a 'transaction' for one thread to complete together without having to write alternate non-locking member functions to invoke for each part of a transaction.
.PP
Strangely enough, the original pthread draft standard does not directly support recursive mutexes. In fact this is the most common 'NP' extension for most pthread implementations. Common C++ emulates recursive mutex behavior when the target platform does not directly support it.
.PP
In addition to the Mutex, Common C++ supports a rwlock class. This implements the X/Open recommended 'rwlock'. On systems which do not support rwlock's, the behavior is emulated with a Mutex; however, the advantage of a rwlock over a mutex is then entirely lost. There has been some suggested clever hacks for 'emulating' the behavior of a rwlock with a pair of mutexes and a semaphore, and one of these will be adapted for Common C++ in the future for platforms that do not support rwlock's directly.
.PP
\fBAuthor: \fP
.in +1c
David Sugar <dyfet@ostel.com> 
.PP
.SH "CONSTRUCTOR & DESTRUCTOR DOCUMENTATION"
.PP 
.SS "Mutex::Mutex ()"
.PP
The mutex is always initialized as a recursive entity.
.PP
.SS "virtual Mutex::~Mutex ()\fC [virtual]\fP"
.PP
Destroying the mutex removes any system resources associated with it.
.PP
If a mutex lock is currently in place, it is presumed to terminate when the Mutex is destroyed. 
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "void Mutex::enterMutex (void)"
.PP
Entering a Mutex locks the mutex for the current thread.
.PP
This also can be done using the ENTER_CRITICAL macro or by using the ++ operator on a mutex.
.PP
\fBSee also: \fP
.in +1c
\fBleaveMutex\fP 
.SS "void Mutex::leaveMutex (void)"
.PP
Leaving a mutex frees that mutex for use by another thread.
.PP
If the mutex has been entered (invoked) multiple times (recursivily) by the same thread, then it will need to be exited the same number of instances before it is free for re-use. This operation can also be done using the LEAVE_CRITICAL macro or by the -- operator on a mutex.
.PP
\fBSee also: \fP
.in +1c
\fBenterMutex\fP 
.SS "bool Mutex::tryEnterMutex (void)"
.PP
Tries to lock the mutex for the current thread.
.PP
Behaves like \fBenterMutex\fP , except that it doesn't block the calling thread if the mutex is already locked by another thread.
.PP
\fBReturns: \fP
.in +1c
true if locking the mutex was succesful otherwise false
.PP
\fBSee also: \fP
.in +1c
\fBenterMutex\fP , \fBleaveMutex\fP 
.SH "FRIENDS AND RELATED FUNCTION DOCUMENTATION"
.PP 
.SS "friend class Conditional\fC [friend]\fP"
.PP
.SS "friend class Event\fC [friend]\fP"
.PP


.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
