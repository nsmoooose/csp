.TH "Slog" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Slog \- The slog class is used to stream messages to the system's logging facility (syslogd). system logging facility class. 
.SH SYNOPSIS
.br
.PP
\fC#include <slog.h>\fP
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef enum Slog::Class \fBClass\fP"
.br
.ti -1c
.RI "typedef enum Slog::Level \fBLevel\fP"
.br
.ti -1c
.RI "enum \fBClass\fP { \fBclassSecurity\fP, \fBclassAudit\fP, \fBclassDaemon\fP, \fBclassUser\fP, \fBclassDefault\fP, \fBclassLocal0\fP, \fBclassLocal1\fP, \fBclassLocal2\fP, \fBclassLocal3\fP, \fBclassLocal4\fP, \fBclassLocal5\fP, \fBclassLocal6\fP, \fBclassLocal7\fP }"
.br
.ti -1c
.RI "enum \fBLevel\fP { \fBlevelEmergency\fP =  1, \fBlevelAlert\fP, \fBlevelCritical\fP, \fBlevelError\fP, \fBlevelWarning\fP, \fBlevelNotice\fP, \fBlevelInfo\fP, \fBlevelDebug\fP }"
.br
.in -1c
.SS "Public Methods"

.in +1c
.ti -1c
.RI "\fBSlog\fP (void)"
.br
.RI "\fIDefault (and only) constructor.\fP"
.ti -1c
.RI "virtual \fB~Slog\fP (void)"
.br
.ti -1c
.RI "void \fBclose\fP (void)"
.br
.ti -1c
.RI "void \fBopen\fP (const char *ident, \fBClass\fP grp=classUser)"
.br
.RI "\fI(re)opens the output stream.\fP"
.ti -1c
.RI "Slog & \fBoperator()\fP (const char *ident, \fBClass\fP grp=classUser, \fBLevel\fP level=levelError)"
.br
.RI "\fISets the log identifier, level, and class to use for subsequent output.\fP"
.ti -1c
.RI "Slog & \fBoperator()\fP (\fBLevel\fP level, \fBClass\fP grp=classDefault)"
.br
.RI "\fIChanges the log level and class to use for subsequent output.\fP"
.ti -1c
.RI "Slog & \fBoperator()\fP (void)"
.br
.RI "\fIDoes nothing except return *this.\fP"
.ti -1c
.RI "void \fBlevel\fP (\fBLevel\fP enable)"
.br
.RI "\fISets the logging level.\fP"
.ti -1c
.RI "void \fBclogEnable\fP (bool f=true)"
.br
.RI "\fIEnables or disables the echoing of the messages to clog in addition to the syslog daemon.\fP"
.ti -1c
.RI "Slog & \fBwarn\fP (void)"
.br
.ti -1c
.RI "Slog & \fBerror\fP (void)"
.br
.ti -1c
.RI "Slog & \fBdebug\fP (void)"
.br
.ti -1c
.RI "Slog & \fBemerg\fP (void)"
.br
.ti -1c
.RI "Slog & \fBalert\fP (void)"
.br
.ti -1c
.RI "Slog & \fBcritical\fP (void)"
.br
.ti -1c
.RI "Slog & \fBnotice\fP (void)"
.br
.ti -1c
.RI "Slog & \fBinfo\fP (void)"
.br
.in -1c
.SS "Protected Methods"

.in +1c
.ti -1c
.RI "int \fBoverflow\fP (int c)"
.br
.RI "\fIThis is the streambuf function that actually outputs the data to the device.\fP"
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
The slog class is used to stream messages to the system's logging facility (syslogd). system logging facility class.
.PP
A default \fCslog\fP object is used to avoid confusion with the native syslog facility and to imply a logical relationship to the C++ \fCclog()\fP.
.PP
The key difference is that the \fCslog\fP object sends it's output to the system logging daemon (typically syslogd) rather than through stderr. \fCslog\fP can be streamed with the \fC<<\fP operator just like \fCclog\fP; a default slog object is pre-initialized, and you stream character data to it.
.PP
The \fCslog\fP allows one to specify logging levels and other properties through the \fC()\fP operators. Hence, once can do:
.PP
\fC.nf

 slog('mydaemon', SLOG_DAEMON, SLOG_EMERGENCY) << I just died << endl; 
.fi
\fP
.PP
or things like:
.PP
\fC.nf

 slog('mydaemon', SLOG_DAEMON); 
 slog(SLOG_INFO) << 'daemon initalized' << endl; 
.fi
\fP
.PP
The intent is to be as common-place and as convenient to use as the stderr based clog facility found in C++, and this is especially useful for C++ daemons.
.PP
The \fCstd::flush\fP manipulator doesn't work. Either the \fCstd::endl\fP or \fCstd::ends\fP manipulators must be used to cause the output to be sent to the daemon.
.PP
When this class is used on a system that doesn't have the syslog headers (i.e. a non-posix win32 box), the output goes to the a file with the same name as the syslog identifier string with '.log' appended to it. If the identifier string ends in '.exe', the '.exe' is removed before the '.log' is appened. (e.g. the identifier foo.exe will generate a log file named foo.log)
.PP
\fBAuthor: \fP
.in +1c
David Sugar <dyfet@ostel.com> 
.br
Minor docs & hacks by Jon Little <littlej@arlut.utexas.edu> 
.PP
.SH "MEMBER TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef enum Slog::Class  Slog::Class"
.PP
.SS "typedef enum Slog::Level  Slog::Level"
.PP
.SH "MEMBER ENUMERATION DOCUMENTATION"
.PP 
.SS "enum Slog::Class"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIclassSecurity\fP \fP\fP
.TP
\fB\fI\fIclassAudit\fP \fP\fP
.TP
\fB\fI\fIclassDaemon\fP \fP\fP
.TP
\fB\fI\fIclassUser\fP \fP\fP
.TP
\fB\fI\fIclassDefault\fP \fP\fP
.TP
\fB\fI\fIclassLocal0\fP \fP\fP
.TP
\fB\fI\fIclassLocal1\fP \fP\fP
.TP
\fB\fI\fIclassLocal2\fP \fP\fP
.TP
\fB\fI\fIclassLocal3\fP \fP\fP
.TP
\fB\fI\fIclassLocal4\fP \fP\fP
.TP
\fB\fI\fIclassLocal5\fP \fP\fP
.TP
\fB\fI\fIclassLocal6\fP \fP\fP
.TP
\fB\fI\fIclassLocal7\fP \fP\fP

.SS "enum Slog::Level"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIlevelEmergency\fP \fP\fP
.TP
\fB\fI\fIlevelAlert\fP \fP\fP
.TP
\fB\fI\fIlevelCritical\fP \fP\fP
.TP
\fB\fI\fIlevelError\fP \fP\fP
.TP
\fB\fI\fIlevelWarning\fP \fP\fP
.TP
\fB\fI\fIlevelNotice\fP \fP\fP
.TP
\fB\fI\fIlevelInfo\fP \fP\fP
.TP
\fB\fI\fIlevelDebug\fP \fP\fP

.SH "CONSTRUCTOR & DESTRUCTOR DOCUMENTATION"
.PP 
.SS "Slog::Slog (void)"
.PP
Default (and only) constructor.
.PP
The default log level is set to SLOG_DEBUG. There is no default log facility set. One should be set before attempting any output. This is done by the \fC\fBopen()\fP\fP or the \fC\fBoperator()(const char *, Class, Level)\fP\fP functions. 
.SS "virtual Slog::~Slog (void)\fC [virtual]\fP"
.PP
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "Slog& Slog::alert (void)\fC [inline]\fP"
.PP
.SS "void Slog::clogEnable (bool f = true)\fC [inline]\fP"
.PP
Enables or disables the echoing of the messages to clog in addition to the syslog daemon.
.PP
This is enabled by the default class constructor. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIf\fP\fP
true to enable, false to disable clog output 
.SS "void Slog::close (void)"
.PP
.SS "Slog& Slog::critical (void)\fC [inline]\fP"
.PP
.SS "Slog& Slog::debug (void)\fC [inline]\fP"
.PP
.SS "Slog& Slog::emerg (void)\fC [inline]\fP"
.PP
.SS "Slog& Slog::error (void)\fC [inline]\fP"
.PP
.SS "Slog& Slog::info (void)\fC [inline]\fP"
.PP
.SS "void Slog::level (\fBLevel\fP enable)\fC [inline]\fP"
.PP
Sets the logging level.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
is the logging level to use for further output 
.SS "Slog& Slog::notice (void)\fC [inline]\fP"
.PP
.SS "void Slog::open (const char * ident, \fBClass\fP grp = classUser)"
.PP
(re)opens the output stream.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIident\fP\fP
The identifier portion of the message sent to the syslog daemon. 
.TP
\fB\fIgrp\fP\fP
The log facility the message is sent to 
.SS "Slog& Slog::operator() (void)"
.PP
Does nothing except return *this.
.PP
.SS "Slog& Slog::operator() (\fBLevel\fP level, \fBClass\fP grp = classDefault)"
.PP
Changes the log level and class to use for subsequent output.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIlevel\fP\fP
The log level of the message 
.TP
\fB\fIgrp\fP\fP
The log facility the message is sent to 
.SS "Slog& Slog::operator() (const char * ident, \fBClass\fP grp = classUser, \fBLevel\fP level = levelError)"
.PP
Sets the log identifier, level, and class to use for subsequent output.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIident\fP\fP
The identifier portion of the message 
.TP
\fB\fIgrp\fP\fP
The log facility the message is sent to 
.TP
\fB\fIlevel\fP\fP
The log level of the message 
.SS "int Slog::overflow (int c)\fC [protected]\fP"
.PP
This is the streambuf function that actually outputs the data to the device.
.PP
Since all output should be done with the standard ostream operators, this function should never be called directly. 
.SS "Slog& Slog::warn (void)\fC [inline]\fP"
.PP


.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
