.TH "Socket" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Socket \- The Socket is used as the base for all Internet protocol services under Common C++. base class of all sockets. 
.SH SYNOPSIS
.br
.PP
\fC#include <socket.h>\fP
.PP
Inherited by \fBSocketPort\fP, \fBTCPSocket\fP\fC [protected]\fP, \fBTCPStream\fP, \fBUDPSocket\fP, \fBUnixSocket\fP\fC [protected]\fP, and \fBUnixStream\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef enum Error \fBError\fP"
.br
.ti -1c
.RI "typedef enum Tos \fBTos\fP"
.br
.ti -1c
.RI "typedef enum Pending \fBPending\fP"
.br
.ti -1c
.RI "enum \fBError\fP { \fBerrSuccess\fP =  0, \fBerrCreateFailed\fP, \fBerrCopyFailed\fP, \fBerrInput\fP, \fBerrInputInterrupt\fP, \fBerrResourceFailure\fP, \fBerrOutput\fP, \fBerrOutputInterrupt\fP, \fBerrNotConnected\fP, \fBerrConnectRefused\fP, \fBerrConnectRejected\fP, \fBerrConnectTimeout\fP, \fBerrConnectFailed\fP, \fBerrConnectInvalid\fP, \fBerrConnectBusy\fP, \fBerrConnectNoRoute\fP, \fBerrBindingFailed\fP, \fBerrBroadcastDenied\fP, \fBerrRoutingDenied\fP, \fBerrKeepaliveDenied\fP, \fBerrServiceDenied\fP, \fBerrServiceUnavailable\fP, \fBerrMulticastDisabled\fP, \fBerrTimeout\fP, \fBerrNoDelay\fP, \fBerrExtended\fP }"
.br
.ti -1c
.RI "enum \fBTos\fP { \fBtosLowDelay\fP =  0, \fBtosThroughput\fP, \fBtosReliability\fP, \fBtosMinCost\fP, \fBtosInvalid\fP }"
.br
.ti -1c
.RI "enum \fBPending\fP { \fBpendingInput\fP, \fBpendingOutput\fP, \fBpendingError\fP }"
.br
.in -1c
.SS "Public Methods"

.in +1c
.ti -1c
.RI "virtual \fB~Socket\fP ()"
.br
.RI "\fIThe socket base class may be 'thrown' as a result of an error, and the 'catcher' may then choose to destroy the object.\fP"
.ti -1c
.RI "Socket & \fBoperator=\fP (const Socket &from)"
.br
.RI "\fISockets may also be duplicated by the assignment operator.\fP"
.ti -1c
.RI "\fBInetHostAddress\fP \fBgetSender\fP (\fBtpport_t\fP *port=NULL) const"
.br
.RI "\fIMay be used to examine the origin of data waiting in the socket receive queue.\fP"
.ti -1c
.RI "\fBInetHostAddress\fP \fBgetPeer\fP (\fBtpport_t\fP *port=NULL) const"
.br
.RI "\fIGet the host address and port of the socket this socket is connected to.\fP"
.ti -1c
.RI "\fBInetHostAddress\fP \fBgetLocal\fP (\fBtpport_t\fP *port=NULL) const"
.br
.RI "\fIGet the local address and port number this socket is currently bound to.\fP"
.ti -1c
.RI "void \fBsetCompletion\fP (bool immediate)"
.br
.RI "\fIUsed to specify blocking mode for the socket.\fP"
.ti -1c
.RI "\fBError\fP \fBsetLinger\fP (bool \fBlinger\fP)"
.br
.RI "\fIEnable lingering sockets on close.\fP"
.ti -1c
.RI "\fBError\fP \fBsetKeepAlive\fP (bool enable)"
.br
.RI "\fISet the keep-alive status of this socket and if keep-alive messages will be sent.\fP"
.ti -1c
.RI "\fBError\fP \fBsetTypeOfService\fP (\fBTos\fP service)"
.br
.RI "\fISet packet scheduling on platforms which support ip quality of service conventions.\fP"
.ti -1c
.RI "bool \fBisConnected\fP (void) const"
.br
.RI "\fICan test to see if this socket is 'connected', and hence whether a 'catch' can safely call \fBgetPeer()\fP.\fP"
.ti -1c
.RI "bool \fBisActive\fP (void) const"
.br
.RI "\fITest to see if the socket is at least operating or if it is mearly initialized.\fP"
.ti -1c
.RI "bool \fBoperator!\fP () const"
.br
.RI "\fIOperator based testing to see if a socket is currently active.\fP"
.ti -1c
.RI "bool \fBisBroadcast\fP (void) const"
.br
.RI "\fIReturn if broadcast has been enabled for the specified socket.\fP"
.ti -1c
.RI "bool \fBisRouted\fP (void) const"
.br
.RI "\fIReturn if socket routing is enabled.\fP"
.ti -1c
.RI "\fBError\fP \fBgetErrorNumber\fP (void) const"
.br
.RI "\fIOften used by a 'catch' to fetch the last error of a thrown socket.\fP"
.ti -1c
.RI "const char * \fBgetErrorString\fP (void) const"
.br
.RI "\fIOften used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED error codes are used.\fP"
.ti -1c
.RI "virtual bool \fBisPending\fP (\fBPending\fP pend, \fBtimeout_t\fP timeout=TIMEOUT_INF)"
.br
.RI "\fIGet the status of pending operations.\fP"
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef enum State \fBState\fP"
.br
.ti -1c
.RI "enum \fBState\fP { \fBINITIAL\fP, \fBAVAILABLE\fP, \fBBOUND\fP, \fBCONNECTED\fP, \fBCONNECTING\fP, \fBSTREAM\fP }"
.br
.in -1c
.SS "Protected Methods"

.in +1c
.ti -1c
.RI "\fBError\fP \fBerror\fP (\fBError\fP error, char *errstr=NULL) const"
.br
.RI "\fIThis service is used to throw all socket errors which usually occur during the socket constructor.\fP"
.ti -1c
.RI "void \fBerror\fP (char *errstr) const"
.br
.RI "\fIThis service is used to throw application defined socket errors where the application specific error code is a string.\fP"
.ti -1c
.RI "void \fBsetError\fP (bool enable)"
.br
.RI "\fIThis service is used to turn the error handler on or off for 'throwing' exceptions by manipulating the thrown flag.\fP"
.ti -1c
.RI "void \fBendSocket\fP (void)"
.br
.RI "\fIUsed as the default destructor for ending a socket.\fP"
.ti -1c
.RI "\fBError\fP \fBconnectError\fP (void)"
.br
.RI "\fIUsed as a common handler for connection failure processing.\fP"
.ti -1c
.RI "\fBError\fP \fBsetBroadcast\fP (bool enable)"
.br
.RI "\fISet the subnet broadcast flag for the socket.\fP"
.ti -1c
.RI "\fBError\fP \fBsetMulticast\fP (bool enable)"
.br
.RI "\fISetting multicast binds the multicast interface used for the socket to the interface the socket itself has been implicitly bound to.\fP"
.ti -1c
.RI "\fBError\fP \fBsetLoopback\fP (bool enable)"
.br
.RI "\fISet the multicast loopback flag for the socket.\fP"
.ti -1c
.RI "\fBError\fP \fBsetTimeToLive\fP (unsigned char \fBttl\fP)"
.br
.RI "\fISet the multicast time to live for a multicast socket.\fP"
.ti -1c
.RI "\fBError\fP \fBjoin\fP (const \fBInetMcastAddress\fP &ia)"
.br
.RI "\fIJoin a multicast group.\fP"
.ti -1c
.RI "\fBError\fP \fBdrop\fP (const \fBInetMcastAddress\fP &ia)"
.br
.RI "\fIDrop membership from a multicast group.\fP"
.ti -1c
.RI "\fBError\fP \fBsetRouting\fP (bool enable)"
.br
.RI "\fISet the socket routing to indicate if outgoing messages should bypass normal routing (set false).\fP"
.ti -1c
.RI "\fBError\fP \fBsetNoDelay\fP (bool enable)"
.br
.RI "\fIEnable/disable delaying packets (Nagle algorithm).\fP"
.ti -1c
.RI "\fBSocket\fP (int domain, int type, int protocol=0)"
.br
.RI "\fIAn unconnected socket may be created directly on the local machine.\fP"
.ti -1c
.RI "\fBSocket\fP (\fBSOCKET\fP fd)"
.br
.RI "\fIA socket object may be created from a file descriptor when that descriptor was created either through a socket() or accept() call.\fP"
.ti -1c
.RI "\fBSocket\fP (const Socket &source)"
.br
.RI "\fIA socket can also be constructed from an already existing Socket object.\fP"
.ti -1c
.RI "ssize_t \fBreadLine\fP (char *buf, size_t len, \fBtimeout_t\fP timeout=0)"
.br
.RI "\fI\fBProcess\fP a logical input line from a socket descriptor directly.\fP"
.ti -1c
.RI "virtual ssize_t \fBreadData\fP (void *buf, size_t len, char separator=0, \fBtimeout_t\fP t=0)"
.br
.RI "\fIRead in a block of len bytes with specific separator.\fP"
.ti -1c
.RI "virtual ssize_t \fBwriteData\fP (const void *buf, size_t len, \fBtimeout_t\fP t=0)"
.br
.RI "\fIWrite a block of len bytes to socket.\fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   bool \fBthrown\fP: 1"
.br
.ti -1c
.RI "   bool \fBbroadcast\fP: 1"
.br
.ti -1c
.RI "   bool \fBroute\fP: 1"
.br
.ti -1c
.RI "   bool \fBkeepalive\fP: 1"
.br
.ti -1c
.RI "   bool \fBloopback\fP: 1"
.br
.ti -1c
.RI "   bool \fBmulticast\fP: 1"
.br
.ti -1c
.RI "   bool \fBcompletion\fP: 1"
.br
.ti -1c
.RI "   bool \fBlinger\fP: 1"
.br
.ti -1c
.RI "   unsigned \fBttl\fP: 8"
.br
.ti -1c
.RI "} \fBflags\fP"
.br
.RI ""
.br
.ti -1c
.RI "\fBSOCKET\fP \fBso\fP"
.br
.RI "\fIthe actual socket descriptor, in Windows, unlike posix it *cannot* be used as an file descriptor that way madness lies -- jfc\fP"
.ti -1c
.RI "\fBState\fP \fBstate\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBSOCKET\fP \fBdupSocket\fP (\fBSOCKET\fP s, \fBSocket::State\fP \fBstate\fP)"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
The Socket is used as the base for all Internet protocol services under Common C++. base class of all sockets.
.PP
A socket is a system resource (or winsock descriptor) that occupies a specific port address (and may be bound to a specific network interface) on the local machine. The socket may also be directly connected to a specific socket on a remote internet host.
.PP
This base class is not directly used, but is provided to offer properties common to other Common C++ socket classes, including the socket exception model and the ability to set socket properties such as QoS, 'sockopts' properties like Dont-Route and Keep-Alive, etc.
.PP
\fBAuthor: \fP
.in +1c
David Sugar <dyfet@ostel.com> 
.PP
.SH "MEMBER TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef enum Error Socket::Error"
.PP
Reimplemented in \fBURLStream\fP.
.SS "typedef enum Pending Socket::Pending"
.PP
.SS "typedef enum State Socket::State\fC [protected]\fP"
.PP
.SS "typedef enum Tos Socket::Tos"
.PP
.SH "MEMBER ENUMERATION DOCUMENTATION"
.PP 
.SS "enum Socket::Error"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIerrSuccess\fP \fP\fP
.TP
\fB\fI\fIerrCreateFailed\fP \fP\fP
.TP
\fB\fI\fIerrCopyFailed\fP \fP\fP
.TP
\fB\fI\fIerrInput\fP \fP\fP
.TP
\fB\fI\fIerrInputInterrupt\fP \fP\fP
.TP
\fB\fI\fIerrResourceFailure\fP \fP\fP
.TP
\fB\fI\fIerrOutput\fP \fP\fP
.TP
\fB\fI\fIerrOutputInterrupt\fP \fP\fP
.TP
\fB\fI\fIerrNotConnected\fP \fP\fP
.TP
\fB\fI\fIerrConnectRefused\fP \fP\fP
.TP
\fB\fI\fIerrConnectRejected\fP \fP\fP
.TP
\fB\fI\fIerrConnectTimeout\fP \fP\fP
.TP
\fB\fI\fIerrConnectFailed\fP \fP\fP
.TP
\fB\fI\fIerrConnectInvalid\fP \fP\fP
.TP
\fB\fI\fIerrConnectBusy\fP \fP\fP
.TP
\fB\fI\fIerrConnectNoRoute\fP \fP\fP
.TP
\fB\fI\fIerrBindingFailed\fP \fP\fP
.TP
\fB\fI\fIerrBroadcastDenied\fP \fP\fP
.TP
\fB\fI\fIerrRoutingDenied\fP \fP\fP
.TP
\fB\fI\fIerrKeepaliveDenied\fP \fP\fP
.TP
\fB\fI\fIerrServiceDenied\fP \fP\fP
.TP
\fB\fI\fIerrServiceUnavailable\fP \fP\fP
.TP
\fB\fI\fIerrMulticastDisabled\fP \fP\fP
.TP
\fB\fI\fIerrTimeout\fP \fP\fP
.TP
\fB\fI\fIerrNoDelay\fP \fP\fP
.TP
\fB\fI\fIerrExtended\fP \fP\fP

.PP
Reimplemented in \fBURLStream\fP.
.SS "enum Socket::Pending"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIpendingInput\fP \fP\fP
.TP
\fB\fI\fIpendingOutput\fP \fP\fP
.TP
\fB\fI\fIpendingError\fP \fP\fP

.SS "enum Socket::State\fC [protected]\fP"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIINITIAL\fP \fP\fP
.TP
\fB\fI\fIAVAILABLE\fP \fP\fP
.TP
\fB\fI\fIBOUND\fP \fP\fP
.TP
\fB\fI\fICONNECTED\fP \fP\fP
.TP
\fB\fI\fICONNECTING\fP \fP\fP
.TP
\fB\fI\fISTREAM\fP \fP\fP

.SS "enum Socket::Tos"
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fItosLowDelay\fP \fP\fP
.TP
\fB\fI\fItosThroughput\fP \fP\fP
.TP
\fB\fI\fItosReliability\fP \fP\fP
.TP
\fB\fI\fItosMinCost\fP \fP\fP
.TP
\fB\fI\fItosInvalid\fP \fP\fP

.SH "CONSTRUCTOR & DESTRUCTOR DOCUMENTATION"
.PP 
.SS "Socket::Socket (int domain, int type, int protocol = 0)\fC [protected]\fP"
.PP
An unconnected socket may be created directly on the local machine.
.PP
Sockets can occupy both the internet domain (AF_INET) and UNIX socket domain (AF_UNIX) under unix. The socket type (SOCK_STREAM, SOCK_DGRAM) and protocol may also be specified. If the socket cannot be created, an exception is thrown.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIdomain\fP\fP
socket domain to use. 
.TP
\fB\fItype\fP\fP
base type and protocol family of the socket. 
.TP
\fB\fIprotocol\fP\fP
specific protocol to apply. 
.SS "Socket::Socket (\fBSOCKET\fP fd)\fC [protected]\fP"
.PP
A socket object may be created from a file descriptor when that descriptor was created either through a socket() or accept() call.
.PP
This constructor is mostly for internal use.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIfd\fP\fP
file descriptor of an already existing socket. 
.SS "Socket::Socket (const Socket & source)\fC [protected]\fP"
.PP
A socket can also be constructed from an already existing Socket object.
.PP
On POSIX systems, the socket file descriptor is dup()'d. On Win32, DuplicateHandle() is used.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsource\fP\fP
of existing socket to clone. 
.SS "virtual Socket::~Socket ()\fC [virtual]\fP"
.PP
The socket base class may be 'thrown' as a result of an error, and the 'catcher' may then choose to destroy the object.
.PP
By assuring the socket base class is a virtual destructor, we can assure the full object is properly terminated. 
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "\fBError\fP Socket::connectError (void)\fC [protected]\fP"
.PP
Used as a common handler for connection failure processing.
.PP
\fBReturns: \fP
.in +1c
correct failure code to apply. 
.SS "\fBError\fP Socket::drop (const \fBInetMcastAddress\fP & ia)\fC [protected]\fP"
.PP
Drop membership from a multicast group.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIia\fP\fP
address of multicast group to drop. 
.PP
Reimplemented in \fBUDPReceive\fP.
.SS "void Socket::endSocket (void)\fC [protected]\fP"
.PP
Used as the default destructor for ending a socket.
.PP
This will cleanly terminate the socket connection. It is provided for use in derived virtual destructors. 
.SS "void Socket::error (char * errstr) const\fC [inline, protected]\fP"
.PP
This service is used to throw application defined socket errors where the application specific error code is a string.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIerrstr\fP\fP
string or message to pass. 
.SS "\fBError\fP Socket::error (\fBError\fP error, char * errstr = NULL) const\fC [protected]\fP"
.PP
This service is used to throw all socket errors which usually occur during the socket constructor.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIerror\fP\fP
defined socket error id. 
.TP
\fB\fIerrstr\fP\fP
string or message to pass. 
.SS "\fBError\fP Socket::getErrorNumber (void) const\fC [inline]\fP"
.PP
Often used by a 'catch' to fetch the last error of a thrown socket.
.PP
\fBReturns: \fP
.in +1c
error number of Error error. 
.SS "const char* Socket::getErrorString (void) const\fC [inline]\fP"
.PP
Often used by a 'catch' to fetch the user set error string of a thrown socket, but only if EXTENDED error codes are used.
.PP
\fBReturns: \fP
.in +1c
string for error message. 
.SS "\fBInetHostAddress\fP Socket::getLocal (\fBtpport_t\fP * port = NULL) const"
.PP
Get the local address and port number this socket is currently bound to.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIport\fP\fP
ptr to port number on local host. 
.PP
\fBReturns: \fP
.in +1c
host address of interface this socket is bound to. 
.PP
Reimplemented in \fBTCPSocket\fP.
.SS "\fBInetHostAddress\fP Socket::getPeer (\fBtpport_t\fP * port = NULL) const"
.PP
Get the host address and port of the socket this socket is connected to.
.PP
If the socket is currently not in a connected state, then a host address of 0.0.0.0 is returned.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIport\fP\fP
ptr to port number of remote socket. 
.PP
\fBReturns: \fP
.in +1c
host address of remote socket. 
.PP
Reimplemented in \fBUDPSocket\fP.
.SS "\fBInetHostAddress\fP Socket::getSender (\fBtpport_t\fP * port = NULL) const"
.PP
May be used to examine the origin of data waiting in the socket receive queue.
.PP
This can tell a TCP server where pending 'connect' requests are coming from, or a UDP socket where it's next packet arrived from.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIport\fP\fP
ptr to port number of sender. 
.PP
\fBReturns: \fP
.in +1c
host address, test with 'isInetAddress()'. 
.SS "bool Socket::isActive (void) const"
.PP
Test to see if the socket is at least operating or if it is mearly initialized.
.PP
'initialized' sockets may be the result of failed constructors.
.PP
\fBReturns: \fP
.in +1c
true if not in initial state. 
.SS "bool Socket::isBroadcast (void) const\fC [inline]\fP"
.PP
Return if broadcast has been enabled for the specified socket.
.PP
\fBReturns: \fP
.in +1c
true if broadcast socket. 
.SS "bool Socket::isConnected (void) const"
.PP
Can test to see if this socket is 'connected', and hence whether a 'catch' can safely call \fBgetPeer()\fP.
.PP
Of course, an unconnected socket will return a 0.0.0.0 address from \fBgetPeer()\fP as well.
.PP
\fBReturns: \fP
.in +1c
true when socket is connected to a peer. 
.SS "virtual bool Socket::isPending (\fBPending\fP pend, \fBtimeout_t\fP timeout = TIMEOUT_INF)\fC [virtual]\fP"
.PP
Get the status of pending operations.
.PP
This can be used to examine if input or output is waiting, or if an error has occured on the descriptor.
.PP
\fBReturns: \fP
.in +1c
true if ready, false on timeout. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIpend\fP\fP
ready check to perform. 
.TP
\fB\fItimeout\fP\fP
in milliseconds, inf. if not specified. 
.PP
Reimplemented in \fBTCPStream\fP, and \fBUnixStream\fP.
.SS "bool Socket::isRouted (void) const\fC [inline]\fP"
.PP
Return if socket routing is enabled.
.PP
\fBReturns: \fP
.in +1c
true if routing enabled. 
.SS "\fBError\fP Socket::join (const \fBInetMcastAddress\fP & ia)\fC [protected]\fP"
.PP
Join a multicast group.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIia\fP\fP
address of multicast group to join. 
.PP
Reimplemented in \fBUDPReceive\fP.
.SS "bool Socket::operator! ()"
.PP
Operator based testing to see if a socket is currently active.
.PP
Reimplemented in \fBtcpstream\fP, and \fBunixstream\fP.
.SS "Socket& Socket::operator= (const Socket & from)"
.PP
Sockets may also be duplicated by the assignment operator.
.PP
.SS "virtual ssize_t Socket::readData (void * buf, size_t len, char separator = 0, \fBtimeout_t\fP t = 0)\fC [protected, virtual]\fP"
.PP
Read in a block of len bytes with specific separator.
.PP
Can be zero, or any other char. If 
.br
 or \\r, it's treated just like a \fBreadLine()\fP. Otherwise it looks for the separator.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIpointer\fP\fP
to byte allocation. 
.TP
\fB\fImaximum\fP\fP
length to read. 
.TP
\fB\fItimeout\fP\fP
for pending data in milliseconds. 
.TP
\fB\fIseparator\fP\fP
for a particular ASCII character 
.PP
\fBReturns: \fP
.in +1c
number of bytes actually read. 
.SS "ssize_t Socket::readLine (char * buf, size_t len, \fBtimeout_t\fP timeout = 0)\fC [protected]\fP"
.PP
\fBProcess\fP a logical input line from a socket descriptor directly.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
pointer to string. 
.TP
\fB\fIlen\fP\fP
maximum length to read. 
.TP
\fB\fItimeout\fP\fP
for pending data in milliseconds. 
.PP
\fBReturns: \fP
.in +1c
number of bytes actually read. 
.SS "\fBError\fP Socket::setBroadcast (bool enable)\fC [protected]\fP"
.PP
Set the subnet broadcast flag for the socket.
.PP
This enables sending to a subnet and may require special image privileges depending on the operating system.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
when set to true. 
.PP
Reimplemented in \fBUDPTransmit\fP.
.SS "void Socket::setCompletion (bool immediate)"
.PP
Used to specify blocking mode for the socket.
.PP
A socket can be made non-blocking by setting setCompletion(false) or set to block on all access with setCompletion(true). I do not believe this form of non-blocking socket I/O is supported in winsock, though it provides an alternate asynchronous set of socket services.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIimmediate\fP\fP
mode specify socket I/O call blocking mode. 
.SS "void Socket::setError (bool enable)\fC [inline, protected]\fP"
.PP
This service is used to turn the error handler on or off for 'throwing' exceptions by manipulating the thrown flag.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
true to enable handler. 
.SS "\fBError\fP Socket::setKeepAlive (bool enable)"
.PP
Set the keep-alive status of this socket and if keep-alive messages will be sent.
.PP
\fBReturns: \fP
.in +1c
0 on success. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
keep alive messages. 
.SS "\fBError\fP Socket::setLinger (bool linger)"
.PP
Enable lingering sockets on close.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIlinger\fP\fP
specify linger enable. 
.SS "\fBError\fP Socket::setLoopback (bool enable)\fC [protected]\fP"
.PP
Set the multicast loopback flag for the socket.
.PP
Loopback enables a socket to hear what it is sending.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
when set to true. 
.SS "\fBError\fP Socket::setMulticast (bool enable)\fC [protected]\fP"
.PP
Setting multicast binds the multicast interface used for the socket to the interface the socket itself has been implicitly bound to.
.PP
It is also used as a check flag to make sure multicast is enabled before multicast operations are used.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
when set to true. 
.PP
Reimplemented in \fBUDPTransmit\fP, and \fBUDPReceive\fP.
.SS "\fBError\fP Socket::setNoDelay (bool enable)\fC [protected]\fP"
.PP
Enable/disable delaying packets (Nagle algorithm).
.PP
\fBReturns: \fP
.in +1c
0 on success. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
disable Nagle algorithm when set to true. 
.SS "\fBError\fP Socket::setRouting (bool enable)\fC [protected]\fP"
.PP
Set the socket routing to indicate if outgoing messages should bypass normal routing (set false).
.PP
\fBReturns: \fP
.in +1c
0 on success. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIenable\fP\fP
normal routing when set to true. 
.PP
Reimplemented in \fBUDPTransmit\fP, and \fBUDPReceive\fP.
.SS "\fBError\fP Socket::setTimeToLive (unsigned char ttl)\fC [protected]\fP"
.PP
Set the multicast time to live for a multicast socket.
.PP
\fBReturns: \fP
.in +1c
0 (errSuccess) on success, else error code. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIttl\fP\fP
time to live. 
.PP
Reimplemented in \fBUDPTransmit\fP.
.SS "\fBError\fP Socket::setTypeOfService (\fBTos\fP service)"
.PP
Set packet scheduling on platforms which support ip quality of service conventions.
.PP
This effects how packets in the queue are scheduled through the interface.
.PP
\fBReturns: \fP
.in +1c
0 on success, error code on failure. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIservice\fP\fP
type of service enumerated type. 
.PP
Reimplemented in \fBUDPTransmit\fP.
.SS "virtual ssize_t Socket::writeData (const void * buf, size_t len, \fBtimeout_t\fP t = 0)\fC [protected, virtual]\fP"
.PP
Write a block of len bytes to socket.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIpointer\fP\fP
to byte allocation. 
.TP
\fB\fImaximum\fP\fP
length to write. 
.TP
\fB\fItimeout\fP\fP
for pending data in milliseconds. 
.PP
\fBReturns: \fP
.in +1c
number of bytes actually read. 
.SH "FRIENDS AND RELATED FUNCTION DOCUMENTATION"
.PP 
.SS "\fBSOCKET\fP dupSocket (\fBSOCKET\fP s, \fBSocket::State\fP state)\fC [friend]\fP"
.PP
.SH "MEMBER DATA DOCUMENTATION"
.PP 
.SS "bool Socket::broadcast\fC [protected]\fP"
.PP
.SS "bool Socket::completion\fC [protected]\fP"
.PP
.SS "struct { ... }   Socket::flags\fC [protected]\fP"
.PP
.SS "bool Socket::keepalive\fC [protected]\fP"
.PP
.SS "bool Socket::linger\fC [protected]\fP"
.PP
.SS "bool Socket::loopback\fC [protected]\fP"
.PP
.SS "bool Socket::multicast\fC [protected]\fP"
.PP
.SS "bool Socket::route\fC [protected]\fP"
.PP
.SS "\fBSOCKET\fP Socket::so\fC [protected]\fP"
.PP
the actual socket descriptor, in Windows, unlike posix it *cannot* be used as an file descriptor that way madness lies -- jfc
.PP
.SS "\fBState\fP Socket::state\fC [protected]\fP"
.PP
.SS "bool Socket::thrown\fC [protected]\fP"
.PP
.SS "unsigned Socket::ttl\fC [protected]\fP"
.PP


.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
