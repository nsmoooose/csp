.TH "Keydata" 3 "22 May 2003" "CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Keydata \- Keydata objects are used to load and hold 'configuration' data for a given application. load text configuration files into keyword pairs. 
.SH SYNOPSIS
.br
.PP
\fC#include <misc.h>\fP
.PP
Inherits \fBMemPager\fP.
.PP
.SS "Public Methods"

.in +1c
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (CCXX_EMPTY) Keydata()"
.br
.RI "\fICreate an empty key data object.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (CCXX_EMPTY) Keydata(const char *\fBkeypath\fP"
.br
.RI "\fICreate a new key data object and use 'Load' method to load an initial config file section into it.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (virtual)~Keydata()"
.br
.RI "\fIDestroy the keydata object and all allocated memory.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) unlink(void)"
.br
.RI "\fIUnlink the keydata object from the cache file stream.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (int) getCount(const char *sym)"
.br
.RI "\fIGet a count of the number of data 'values' that is associated with a specific keyword.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (const char *) getFirst(const char *sym)"
.br
.RI "\fIGet the first data value for a given keyword.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (const char *) getLast(const char *sym)"
.br
.RI "\fIGet the last (most recently set) value for a given keyword.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (unsigned) getIndex(char **\fBdata\fP"
.br
.RI "\fIGet an index array of ALL keywords that are stored by the current keydata object.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (unsigned) getCount(void)"
.br
.RI "\fIGet the count of keyword indexes that are actually available so one can allocate a table to receive getIndex.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) setValue(const char *sym"
.br
.RI "\fISet (replace) the value of a given keyword.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (const char *const *) getList(const char *sym)"
.br
.RI "\fIReturn a list of all values set for the given keyword returned in order.\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) clrValue(const char *sym)"
.br
.RI "\fIClear all values associated with a given keyword.\fP"
.ti -1c
.RI "const char * \fBoperator[]\fP (const char *keyword)"
.br
.RI "\fIA convient notation for accessing the keydata as an associative array of keyword/value pairs through the [] operator.\fP"
.ti -1c
.RI "friend \fBCCXX_EXPORT\fP (void) endKeydata(void)"
.br
.RI "\fIShutdown the file stream cache.\fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "const char * \fBenvironment\fP = 'CONFIG_KEYDATA')"
.br
.ti -1c
.RI "unsigned \fBmax\fP"
.br
.ti -1c
.RI "const char * \fBdata\fP"
.br
.in -1c
.SS "Protected Methods"

.in +1c
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (\fBKeysym\fP *) getSymbol(const char *sym"
.br
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) load(const char *\fBkeypath\fP"
.br
.RI "\fILoad additional key values into the currrent object from the specfied config source (a config file/section pair).\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) loadPrefix(const char *prefix"
.br
.RI "\fILoad additional key values into the currrent object from the specfied config source (a config file/section pair).\fP"
.ti -1c
.RI "\fBCCXX_MEMBER_EXPORT\fP (void) load(\fBDefine\fP *pairs)"
.br
.RI "\fILoad default keywords into the current object.\fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBcreate\fP"
.br
.ti -1c
.RI "const char * \fBenvironment\fP = 'CONFIG_KEYDATA')"
.br
.ti -1c
.RI "const char * \fBkeypath\fP"
.br
.ti -1c
.RI "const char const char * \fBenvironment\fP = 'CONFIG_KEYDATA')"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
Keydata objects are used to load and hold 'configuration' data for a given application. load text configuration files into keyword pairs.
.PP
This class is used to load and then hold '\fCkeyword = value\fP' pairs parsed from a text based 'config' file that has been divided into '\fC[sections]\fP'. The syntax is:
.PP
\fC.nf

 [section_name]
 key1=value1
 key2=value2
.fi
\fP
.PP
Essentially, the 'path' is a 'keypath' into a theoretical namespace of key pairs, hence one does not use 'real' filepaths that may be OS dependent. The '\fC/\fP' path refers to '\fC/etc\fP' prefixed (on UNIX) directories and this is processed within the constructor. It could refer to the \fC/config\fP prefix on QNX, or even, gasp, a '\fCC:\\WINDOWS\fP'. Hence, a keypath of '\fC/bayonne.d/vmhost/smtp\fP' actually resolves to a '\fC/etc/bayonne.d/vmhost.conf\fP' and loads key value pairs from the \fC[smtp]\fP section of that \fC.conf\fP file.
.PP
Similarly, something like '\fC~bayonne/smtp\fP' path refers to a '\fC~/.bayonnerc\fP' and loads key pairs from the \fC[smtp]\fP section. This coercion occurs before the name is passed to the open call.
.PP
I actually use derived keydata based classes as global initialized objects, and they hence automatically load and parse config file entries even before 'main' has started.
.PP
Keydata can hold multiple values for the same key pair. This can occur either from storing a 'list' of data items in a config file, or when overlaying multiple config sources (such as \fC/etc/....conf\fP and \fC~/.confrc\fP segments) into a single object. The keys are stored as cumulative (read-only/replacable) config values under a hash index system for quick retrieval.
.PP
Keydata can also load a table of 'initialization' values for keyword pairs that were not found in the external file.
.PP
One typically derives an application specific keydata class to load a specific portion of a known config file and initialize it's values. One can then declare a global instance of these objects and have configuration data initialized automatically as the executable is loaded.
.PP
Hence, if I have a '[paths]' section in a '\fC/etc/server.conf?\fP' file, I might define something like:
.PP
\fC.nf

 class KeyPaths : public Keydata
 {
   public:
     KeyPaths() : Keydata('/server/paths')
     {
       static \fBKeydata::Define\fP *defvalues = {
 	  {'datafiles', '/var/server'},
 	  {NULL, NULL}};
 
       // override with [paths] from '~/.serverrc' if avail.
 
       load('~server/paths');
       load(defvalues);
     }
 };
 
 KeyPaths keypaths;
 
.fi
\fP
.PP
\fBAuthor: \fP
.in +1c
David Sugar <dyfet@ostel.com> 
.PP
.SH "MEMBER FUNCTION DOCUMENTATION"
.PP 
.SS "Keydata::CCXX_EXPORT (void)"
.PP
Shutdown the file stream cache.
.PP
This should be used before detaching a deamon, \fCexec()\fP, \fCfork()\fP, etc. 
.SS "Keydata::CCXX_MEMBER_EXPORT (void) const"
.PP
Clear all values associated with a given keyword.
.PP
This does not de-allocate the keyword from memory, however.
.PP
\fBReturns: \fP
.in +1c
keyword name to clear. 
.SS "Keydata::CCXX_MEMBER_EXPORT (const char *const *) const"
.PP
Return a list of all values set for the given keyword returned in order.
.PP
\fBReturns: \fP
.in +1c
list pointer of array holding all keyword values. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsym\fP\fP
keyword name to fetch. 
.SS "Keydata::CCXX_MEMBER_EXPORT (void) const"
.PP
Set (replace) the value of a given keyword.
.PP
This new value will become the value returned from getLast(), while the prior value will still be stored and found from \fCgetList()\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsym\fP\fP
keyword name to set. 
.TP
\fB\fIdata\fP\fP
string to store for the keyword. 
.SS "Keydata::CCXX_MEMBER_EXPORT (unsigned)"
.PP
Get the count of keyword indexes that are actually available so one can allocate a table to receive getIndex.
.PP
\fBReturns: \fP
.in +1c
number of keywords found. 
.SS "Keydata::CCXX_MEMBER_EXPORT (unsigned)"
.PP
Get an index array of ALL keywords that are stored by the current keydata object.
.PP
\fBReturns: \fP
.in +1c
number of keywords found. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIdata\fP\fP
pointer of array to hold keyword strings. 
.TP
\fB\fImax\fP\fP
number of entries the array can hold. 
.SS "Keydata::CCXX_MEMBER_EXPORT (const char *) const"
.PP
Get the last (most recently set) value for a given keyword.
.PP
This is typically the value actually used.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsym\fP\fP
keywork symbol name. 
.PP
\fBReturns: \fP
.in +1c
last set value for this symbol. 
.SS "Keydata::CCXX_MEMBER_EXPORT (const char *) const"
.PP
Get the first data value for a given keyword.
.PP
This will typically be the \fC/etc\fP set global default.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsym\fP\fP
keyword symbol name. 
.PP
\fBReturns: \fP
.in +1c
first set value for this symbol. 
.SS "Keydata::CCXX_MEMBER_EXPORT (int) const"
.PP
Get a count of the number of data 'values' that is associated with a specific keyword.
.PP
Each value is from an accumulation of '\fCload()\fP' requests.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIsym\fP\fP
keyword symbol name. 
.PP
\fBReturns: \fP
.in +1c
count of values associated with keyword. 
.SS "Keydata::CCXX_MEMBER_EXPORT (void)"
.PP
Unlink the keydata object from the cache file stream.
.PP
This should be used if you plan to keepa Keydata object after it is loaded once all keydata objects have been loaded, otherwise the cfgFile stream will remain open. You can also use endKeydata(). 
.SS "Keydata::CCXX_MEMBER_EXPORT (virtual)"
.PP
Destroy the keydata object and all allocated memory.
.PP
This may also clear the 'cache' file stream if no other keydata objects currently reference it. 
.SS "Keydata::CCXX_MEMBER_EXPORT (CCXX_EMPTY) const"
.PP
Create a new key data object and use 'Load' method to load an initial config file section into it.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIkeypath\fP\fP
(filepath/section) 
.TP
\fB\fIenvironment\fP\fP
optional environment variable that specifies the home path. 
.SS "Keydata::CCXX_MEMBER_EXPORT (CCXX_EMPTY)"
.PP
Create an empty key data object.
.PP
.SS "Keydata::CCXX_MEMBER_EXPORT (void)\fC [protected]\fP"
.PP
Load default keywords into the current object.
.PP
This only loads keyword entries which have not already been defined to reduce memory usage. This form of Load is also commonly used in the constructor of a derived Keydata class.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIpairs\fP\fP
list of NULL terminated default keyword/value pairs. 
.SS "Keydata::CCXX_MEMBER_EXPORT (void) const\fC [protected]\fP"
.PP
Load additional key values into the currrent object from the specfied config source (a config file/section pair).
.PP
These values will overlay the current keywords when matches are found. This can be used typically in a derived config object class constructor to first load a \fC/etc\fP section, and then load a matching user specific entry from \fC~/.\fP to override default system values with user specific keyword values. This varient puts a prefix in front of the key name.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIprefix\fP\fP
.TP
\fB\fIkeypath\fP\fP
(filepath/section) 
.TP
\fB\fIenvironment\fP\fP
optional environment variable that specifies the home path. 
.SS "Keydata::CCXX_MEMBER_EXPORT (void) const\fC [protected]\fP"
.PP
Load additional key values into the currrent object from the specfied config source (a config file/section pair).
.PP
These values will overlay the current keywords when matches are found. This can be used typically in a derived config object class constructor to first load a \fC/etc\fP section, and then load a matching user specific entry from \fC~/.\fP to override default system values with user specific keyword values.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIkeypath\fP\fP
(filepath/section) 
.TP
\fB\fIenvironment\fP\fP
string 
.SS "Keydata::CCXX_MEMBER_EXPORT (\fBKeysym\fP *) const\fC [protected]\fP"
.PP
.SS "const char* Keydata::operator[] (const char * keyword)\fC [inline]\fP"
.PP
A convient notation for accessing the keydata as an associative array of keyword/value pairs through the [] operator.
.PP
.SH "MEMBER DATA DOCUMENTATION"
.PP 
.SS "bool Keydata::create\fC [protected]\fP"
.PP
.SS "const char* Keydata::data"
.PP
.SS "const char* Keydata::environment = 'CONFIG_KEYDATA')"
.PP
.SS "const char const char* Keydata::environment = 'CONFIG_KEYDATA')\fC [protected]\fP"
.PP
.SS "const char* Keydata::environment = 'CONFIG_KEYDATA')\fC [protected]\fP"
.PP
.SS "const char* Keydata::keypath\fC [protected]\fP"
.PP
.SS "unsigned Keydata::max"
.PP


.SH "AUTHOR"
.PP 
Generated automatically by Doxygen for CommonC++ from the source code.
