/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_MAP_LAYER_H
#define OSGEARTH_MAP_LAYER_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osgEarth/TileSource>
#include <osgEarth/Profile>
#include <osgEarth/Caching>
#include <osgEarth/TaskService>
#include <osgEarth/DriverOptions>
#include <map>
#include <utility>
#include <queue>
#include <OpenThreads/Mutex>

namespace osgEarth
{
    /**
     * One layer in the map.
     */
    class OSGEARTH_EXPORT MapLayer : public osg::Referenced
    {
    public:
        /**
         * Map layer data types.
         */
        enum Type {
            TYPE_IMAGE,
            TYPE_HEIGHTFIELD
        };

    public: //ctors

        /**
         * Constructs a new map layer with the specified driver options.
         */
        MapLayer(
            const std::string& name,
            Type type,
            const DriverOptions* options );

        /**
         * Constructs a new map layer based on information in a Config object. This is
         * the typical method for creating a layer from a serialized definition (like
         * the .earth file).
         */
        MapLayer(
            Type type,
            const Config& driverConf );

        /**
         * Constructs a new map layer with a user-provided TileSource driver.
         */
        MapLayer(
            const std::string& name,
            Type type,
            TileSource* driver );


    public: // properties

        /**
         * Gets the unique ID of this map layer
         */
        unsigned int getId() const;

        /**
         * Gets the readable name of the map layer.
         */
        const std::string& getName() const;

        /**
         * Gets the layer type of the map layer.
         */
        const Type& getType() const;

        /**
         * Gets the driver options used to create this layer.
         */
        const DriverOptions* getDriverOptions() const {
            return _driverOptions.get(); }

		/**
		 * Gets the profile of this MapLayer
		 */
		const Profile* getProfile() const;

        /**
         * Gets the underlying TileSource engine that serves this map layer. Use with caution.
         */
        TileSource* getTileSource() const;

    public: // properties

        /**
         * Gets the explicit profile setup for this map layer. By default, the layer will 
         * try to automatically determine the Profile from the tile source. This property
         * sets it explicitly instead.
         */
        optional<ProfileConfig>& profileConfig() { return _profileConf; }
        const optional<ProfileConfig>& profileConfig() const { return _profileConf; }

        /**
         * Gets or sets the minimum level of detail for which this layer should generate data.
         */
        optional<int>& minLevel() { return _minLevel; }
        const optional<int>& minLevel() const { return _minLevel; }

        /**
         * The maximum level of detail for which this layer should generate data.
         */
        optional<int>& maxLevel() { return _maxLevel; }
        const optional<int>& maxLevel() const { return _maxLevel; }

		/**
		 * The opacity of this layer's image tile
		 */
        optional<float>& opacity() { return _opacity; }
        const optional<float>& opacity() const { return _opacity; }

        /**
         * The gamma value for this layer's image tiles
         */
        optional<double>& gamma() { return _gamma; }
        const optional<double>& gamma() const { return _gamma; }

		/**
		 * Whether to render this layer with the map.
		 */
        optional<bool>& enabled() { return _enabled; }
        const optional<bool>& enabled() const { return _enabled; }

		/**
		 * Gets or sets the nodata image for this MapLayer
		 */
        optional<std::string>& noDataImageFilename() { return _noDataImageFilename; }
        const optional<std::string>& noDataImageFilename() const { return _noDataImageFilename; }

		/**
		 * Gets the transparent color of this TileSource
		 */
		optional<osg::Vec4ub>& transparentColor() { return _transparentColor; }
        const optional<osg::Vec4ub>& transparentColor() const { return _transparentColor; }

		/**
		 * Whether or not to allow the creation of Mercator images for Geographic scenes
		 */
        optional<bool>& useMercatorFastPath() { return _useMercatorFastPath; }
        const optional<bool>& useMercatorFastPath() const { return _useMercatorFastPath; }

		/**
		 * Whether to use exact cropping if image cropping is necessary
		 */
        optional<bool>& exactCropping() { return _exactCropping; }
        const optional<bool>& exactCropping() const { return _exactCropping; }

		/**
		 * The desired tile size to reproject imagery to if necessary.
		 */
        optional<unsigned int> reprojectedTileSize() { return _reprojectedTileSize; }
        const optional<unsigned int> reprojectedTileSize() const { return _reprojectedTileSize; }

		/**
		 * The format that this MapLayer should use when caching.
		 */
        optional<std::string>& cacheFormat() { return _cacheFormat; }
        const optional<std::string>& cacheFormat() const { return _cacheFormat; }

        /**
         * Whether to cache this layer or not.
         */
        optional<bool>& cacheEnabled() { return _cacheEnabled; }
        const optional<bool>& cacheEnabled() const { return _cacheEnabled; }

		/**
		 * Whether to try to run this MapLayer strictly from the cache only.
		 */
        optional<bool>& cacheOnly() { return _cacheOnly; }
        const optional<bool>& cacheOnly() const { return _cacheOnly; }
        
        /**
         * The loading weight of this MapLayer (for threaded loading policies).
         */
        optional<float> loadingWeight() { return _loadingWeight; }
        const optional<float>& loadingWeight() const { return _loadingWeight; }

        /**
         *The ratio used to expand the extent of a tile when the layer
         *needs to be mosaiced to projected.  This can be used to increase the
         *number of tiles grabbed to ensure that enough data is grabbed to
         *overlap the incoming tile.
         */
        optional<double> edgeBufferRatio() { return _edgeBufferRatio;}
        const optional<double> edgeBufferRatio() const { return _edgeBufferRatio;}

    public: // methods

		/**
		 *Gets whether the given key is valid for this MapLayer
		 */
		bool isKeyValid(const TileKey* key) const;

		/**
		 * Creates a GeoImage from this MapLayer
		 */
		GeoImage* createImage( const TileKey* key,
                               ProgressCallback* progress = 0);

        /**
         * Creates a GeoHeightField for this MapLayer.
         * The returned HeightField will always match the geospatial extents of the incoming TileKey.
         */
        osg::HeightField* createHeightField( const TileKey* key,
                                             ProgressCallback* progress = 0);

		 /**
         * Gets the user-provided options structure stored in this map.
         */
        const osgDB::ReaderWriter::Options* getGlobalOptions() const;

        void setGlobalOptions( const osgDB::ReaderWriter::Options* options );


		/**
         * Gets the reference URI. See setReferenceURI for more info.
         */
        const std::string& getReferenceURI() const;

        /**
         * Sets a reference URI. Usually this is the location of a file from which this map
         * was created. This acts as a reference point for any relative paths/URIS that may
         * occur elsewhere in the configuration.
         *
         * Note: Set this before adding any layers to the map.
         */
        void setReferenceURI( const std::string& uri );


		/**
		 * Gets the Cache to be used on this MapLayer.
		 */
		Cache* getCache() const;

		/**
		 * Sets the cache to be used on this MapLayer
		 */
		void setCache( Cache* cache );

        /**
         * Suggests a cache format for this layer
         */
        std::string suggestCacheFormat() const;

        
        virtual Config toConfig() const;

    protected:

		void initTileSource();

		osg::Image* createImageWrapper( const TileKey* key,
                                        bool cacheInLayerProfile,
                                        ProgressCallback* progress );
		GeoHeightField* createGeoHeightField( const TileKey* key,
                                              ProgressCallback* progress);

		void readEnvironmentalVariables();

        ~MapLayer() { }

    private:
        unsigned int _id;
        std::string _name;
        Type        _type;

        osg::ref_ptr<const DriverOptions> _driverOptions;
       
        optional<ProfileConfig> _profileConf;
        optional<int> _minLevel;
        optional<int> _maxLevel;
	    optional<std::string> _noDataImageFilename;
		optional<osg::Vec4ub> _transparentColor;
        optional<bool> _useMercatorFastPath;
		optional<std::string> _cacheFormat;
        optional<bool> _cacheEnabled;
		optional<bool> _cacheOnly;
        optional<float> _loadingWeight;
        optional<bool> _exactCropping;
		optional<float> _opacity;
        optional<double> _gamma;
		optional<bool> _enabled;
		optional<unsigned int> _reprojectedTileSize;
        optional<double> _edgeBufferRatio;

        bool _cacheOnlyEnv;

        
        osg::ref_ptr<TileSource> _tileSource;
		osg::ref_ptr<Cache> _cache;
	    osg::ref_ptr<osg::Image> _nodata_image;

		std::string _referenceURI;

		osg::ref_ptr<const osgDB::ReaderWriter::Options> _globalOptions;
		osg::ref_ptr< const Profile > _profile;
        osg::ref_ptr< const Profile > _cacheProfile;

        OpenThreads::Mutex _initMutex;
        
        unsigned char _gammaLUT[256];
        double _prevGamma;

        void init();
        void fromConfig( const Config& conf );
        GeoImage* postProcess( GeoImage* img );
    };

    /**
     * Convenience class that automatically sets the TYPE_IMAGE layer type.
     */
    class OSGEARTH_EXPORT ImageMapLayer : public MapLayer
    {
    public:
        ImageMapLayer( const std::string& name, const DriverOptions* options ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, options ) { }
        
        ImageMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, source ) { }
    };
    
    class OSGEARTH_EXPORT HeightFieldMapLayer : public MapLayer
    {
    public:
        HeightFieldMapLayer( const std::string& name, const DriverOptions* options ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, options ) { }
        
        HeightFieldMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, source ) { }
    };


    typedef std::vector< osg::ref_ptr<MapLayer> > MapLayerList;

	class TransparentLayer : public osgTerrain::ImageLayer
	{
	public:
		TransparentLayer(osg::Image* image, MapLayer* mapLayer):
			osgTerrain::ImageLayer(image),
		    _mapLayer(mapLayer),
            _lod(-1)
		{
		}

        unsigned int getId() const
        {
            return _mapLayer->getId();
        }

		float getOpacity() const
		{
            return _mapLayer->opacity().value();
		}

		bool getEnabled() const
		{
			return _mapLayer->enabled().value();
		}

        int getLevelOfDetail() const
        {
            return _lod;
        }

        void setLevelOfDetail(int lod)
        {
            _lod = lod;
        }

		osg::ref_ptr<MapLayer> _mapLayer;
        int _lod;
	};


    class L2Cache
    {
    public:
        L2Cache();
        GeoImage* createImage( MapLayer* layer, const TileKey* key );
        osg::HeightField* createHeightField( MapLayer* layer, const TileKey* key );
    public:
        typedef std::pair<MapLayer*,std::string> TileTag;
        typedef std::map<TileTag,osg::ref_ptr<osg::Referenced> > TileMap;
        typedef std::queue<TileTag> TileTagQueue;
        struct TileCache {
            TileCache() : _hits(0), _misses(0) { }
            TileMap _map;
            TileTagQueue _fifo;
            OpenThreads::Mutex _mutex;
            void put(const TileTag& tag, osg::Referenced* obj);
            osg::Referenced* get(const TileTag& tag);
            int _hits, _misses;
        };

    protected:
        TileCache _cache;
        TaskService* _service;
        void scheduleSubKeys(MapLayer*,const TileKey*);
    };
}

#endif // OSGEARTH_MAP_LAYER_H
