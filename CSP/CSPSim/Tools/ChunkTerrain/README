NOTE that this version is slightly different from the original
release (osgChunkLod-0.1.tar.gz).  See TODO for details. --OS

Original README:
======================================================================

Chunked LOD demo
5 Aug 2002
Thatcher Ulrich <tu@tulrich.com> http://tulrich.com

Demo of chunked LOD scheme.  Uses static meshes with lerping and
crack-filling skirt meshes to give an adjustable guaranteed max pixel
error, no vertex popping and low CPU overhead.  Uses a texture
quadtree scheme to tile massive, seamless geospecific (unique)
textures over large models, using ordinary OpenGL 1.2 functionality.
Loads data in a separate thread, to avoid making the rendering thread
wait for IO.

There are several programs in this package:

* chunkdemo -- the renderer; reads .chu and .tqt or .jpg files, and
  lets you fly around the terrain interactively.  If you just want to
  see the demo, this is the program you want.

* heightfield_chunker -- the tool that precomputes the chunk data, to
  make .chu files.  Reads .bt (Binary Terrain) heightfield files for
  input.

* maketqt -- a preprocessing tool that generate a .tqt (texture
  quadtree) file, from an input .jpg file.  Input and output size not
  limited by available RAM.

* heightfield_shader -- a simple-minded heightfield shading tool.  Can
  generate a gigantic texture to drape over a terrain.  Works on a
  scanline at a time; the output size of the texture is not limited by
  available RAM.

* makebt -- utility to make a .bt file from a .png file.

* decimate_texture -- utility to do a very coarse subsampling of a
  giant .jpg file, to make a smaller .jpg file.  Useful for previewing
  a draft view of large .jpgs.

* dem2bt.pl -- quickie Perl script to make a .bt file from USGS ASCII
  .dem file.

All programs print some usage info when run from the command line.

With NVIDIA's vertex_array_range extension, the demo puts out up to
9.5 million tris/sec at 30 fps on my laptop (1GHz CPU, GeForce2 Go
video) under optimal conditions.  NVIDIA's VAR demo does ~11 Mtris/s
on this machine, so I'm doing pretty well.  Typical throughput is a
little lower than that, but still excellent considering the size and
visual quality of the rendering.

The strips currently generated by the chunker have a lot of degenerate
tris in them; typically more than 0.5x the number of real triangles,
so I think throughput improvement is possible.  I'm just using the
automatic binary-triangle-tree strip generation approach from the
Lindstrom et al SIGGRAPH '96 paper.  A stripifier designed for
arbitrary meshes might be able to do better.

Thanks to John Ratcliff for the crater dataset,
http://ratcliff.flipcode.com

Thanks to Ben Discoe & http://www.vterrain.org for the .bt terrain
file format and for providing some sample .bt data.

Thanks to Ken Musgrave & http://www.pandromeda.com for some nice
procedural sample data.

Thanks to Peter Lindstrom, University of Washington and Georgia Tech
for preparing and hosting the Puget Sound dataset:
http://www.cc.gatech.edu/projects/large_models/

Thanks to the USGS for collecting data and making it available to the
public.

Thanks to Mike Shaver, Thierry Berger-Perrin and Ignacio Castaño for
patches to fix bugs and improve Linux support.

The source code for these programs has been donated to the public
domain; do whatever you want with it.  The home page of this project
is:

	http://tulrich.com/geekstuff/chunklod.html

You can find links to the CVS repository, sample data, and more
documentation there.


USAGE
=====

To view the included crater dataset, run "chunkdemo".  By default it
will look for "crater/crater.chu" and "crater/crater.jpg", and print
some usage info to the console.

To easily view the preprocessed datasets available from the project
homepage, you can run "lua demo_menu.lua".  This shows a text menu of
the various datasets, and launches chunkdemo with the necessary
arguments.

To experiment with other datasets, you need to generate a .chu file
from heightfield data, using the heightfield_chunker program.  If you
run "heightfield_chunker" with no arguments, it will print a usage
summary.  For heightfield data input, you must use the .BT format,
which is a nice convenient format for high-precision terrain data.
This package contains a couple utility programs for making .bt data
from other heightfield file formats.

Run the chunker with "heightfield_chunker input.bt output.chu".  The
program picks some default values for the base error ("-e error") and
tree depth ("-d depth").  Watch the output summary, to see if you
might want to change the default values.  In general, a larger base
error value will generate smaller, less detailed chunk files.  For
tree depth, a higher value is better for bigger datasets, but too high
a value will make chunks without enough vertices in them, and the
overall overhead will be larger.  You probably want an average vertex
per chunk value of somewhere between 1000 and 5000.  That's just a
guess; I haven't systematically explored the tradeoffs.

For less fidelity and smaller data files, you can try raising the base
error value.

You can get some nice sample .BT data at:
http://vterrain.org/BT/index.html .

If you don't have a texture for your dataset, you can make a basic one
using "heightfield_shader".  Example:

	heightfield_shader heightfield.bt output_texture.jpg -g gradient.png

There are various options; run "heightfield_shader" with no args to
see a usage summary.  You can use the generated texture as-is, but
depending on your hardware you may not be able to see any resolution
above say 2048 x 2048 texels.  For really big textures, use the
"maketqt" program to chop up your .jpg file into a texture quadtree.
Example:

	maketqt texture.jpg texture.tqt

For best results, you will want to look at the options of maketqt.
It's not very smart about defaults.

To view the heightfield, use "chunkdemo chunkdata.chu
texture.[jpg|tqt]".  The program will open a rendering window, and
print usage info to the console.  There are some command-line options
to chunkdemo that control resolution, fullscreen rendering, bitdepth,
etc.  Run without args for a summary.


CHANGES
=======

5 Aug 2002

This is basically the version I showed at SIGGRAPH, with a couple bug
fixes.  All the basic functionality is working well; paging of massive
datasets, texture quadtree tiling, LOD with morphing.


ALGORITHM NOTES
===============

Quick summary:

Take a single object, and make a tree of chunks out of it.  Each chunk
is just a static, precomputed mesh that can be rendered with a single
glDrawElements() call.  The chunk at the root of the tree is a
low-detail representation of the entire object.  The child chunks of
the root node split the object into several pieces, and each piece
independently represents its portion of the object, with a higher
level of detail than the parent.  This splitting happens recursively
down to some arbitrary depth.  Each chunk has a bounding volume
associated with it, and each level of the tree has a maximum geometric
error associated with the chunks at that level.  The max geometric
error represents maximum deviation of a chunk mesh from the underlying
object geometry it represents.  In my scheme the max geometric error
reduces by a factor of 2 at every additional level in the tree.  For
example, if the root node of the tree is a single mesh that represents
the object with at most 16 units of deviation from the full-detail
mesh, at the fifth level down the tree, the chunks each represent a
small piece of the object, with only 1 unit of deviation.

There is a paper at http://tulrich.com/geekstuff/chunklod.html which
has much more detail, and covers the interesting parts like morphing,
crack filling, and texturing.


BUILDING
========

Windows and Linux users
-----------------------

1. You should have gotten source code along with the demo, of the same
   version used to build the demo.  For up-to-date code, see
   http://tulrich.com/geekstuff/chunklod.html

Linux Users
-----------

2. You may need to install the development files for Lua 4.0 .  Lua is
   a lightweight but easy-to-use and powerful scripting language, see
   http://www.lua.org for details.  Install lua alongside the
   tu-testbed tree.  For example, if you untarred this project into
   "~/src/tu-testbed/*", then you should put lua in "~/src/lua-4.0".
   If you already have Lua installed somewhere on your system, or you
   want to install it somewhere else, just edit the tu-testbed/config
   file to set the appropriate paths.

3. Make sure you have SDL version 1.2 (or better) installed.  SDL is a
   very popular and widely ported compatibility layer, for access to
   multimedia hardware & interfaces.  See http://www.libsdl.org for
   details.

4. "cd tu-testbed; make"

   Hopefully that does it.  If not, you should look through
   "tu-testbed/config" to make sure you have the other necessary
   libraries, such as libjpeg and libpng.  Most distros will include
   those libs by default.

Windows Users
-------------

2. You need a version of GNU make.  The default Makefiles are set up
   to compile cleanly with the command-line version of MSVC 6.0, but
   GNU make drives the build.

   I use Cygwin under Win32, to provide GNU make and other handy *nix
   tools.  See http://sources.redhat.com/cygwin/

   You may also be able to find GNU make for Win32 without inhaling so
   much *nix.  See http://www.mingw.org for example, or
   http://unxutils.sourceforge.net/

   You can also try dropping everything into a MSVC IDE project if
   you're so inclined.  Theoretically it should work, but I've never
   tried it.

3. You need these libraries:

   Lua -- see http://www.lua.org

   SDL -- see http://www.libsdl.org

   Jpeglib -- see http://www.ijg.org

   libpng -- see http://www.libpng.org

   By default the Makefiles expect these to be installed alongside
   tu-testbed.  You can change the paths by going into
   "tu-testbed/config"; it should be self-explanatory.

4. Open a shell, and do:
   
   > cd tu-testbed
   > make

   Hopefully it works.
